#pragma once

/**
 * ----------------------------------------
 * |        Generated By CheatGear        |
 * ----------------------------------------
 * | Game:    TFDCG                       |
 * | Version: 1                           |
 * | Date:    08/22/2024                  |
 * ----------------------------------------
 */

#include <cstdint>
#include <vector>
#include <string>
#include "Engine_UBlueprintFunctionLibrary.h"
#include "CoreUObject_FVector.h"
#include "CoreUObject_FTransform.h"
#include "Engine_FHitResult.h"
#include "M1Data_FM1ScaledInteger.h"
#include "BasicTypes_TArray.h"
#include "M1_FM1AbilityId.h"
#include "BasicTypes_FName.h"
#include "M1_FM1AbilityOpCalcParam.h"
#include "M1_FM1CalcDamageInfo.h"
#include "M1Data_ENUMS.h"
#include "CoreUObject_FRotator.h"
#include "BasicTypes_TSoftObjectPtr.h"
#include "M1_UM1DataHitEffects.h"
#include "M1_ENUMS.h"
#include "Niagara_UNiagaraSystem.h"
#include "BasicTypes_FString.h"
#include "M1_FM1AbilityEvent.h"
#include "Engine_FPredictProjectilePathPointData.h"
#include "M1_FM1AbilityTargetInfoHandle.h"
#include "M1_FM1AbilityOperationParam.h"
#include "M1_FM1AbilityEventData_WeaponSlotType.h"
#include "M1_FM1AbilityEventDataHandle.h"
#include "M1_FM1AbilityEventData_DamageInfo.h"
#include "M1_FM1AbilityEventData_DamageCalculation.h"
#include "Engine_ENUMS.h"
#include "GameplayTags_FGameplayTagContainer.h"
#include "GameplayTags_FGameplayTag.h"
#include "M1_FM1IntegerId.h"
#include "PhysicsCore_ENUMS.h"
#include "M1_FM1StatRefDesc.h"
#include "M1_FM1NormalMonsterHitReactionData.h"
#include "Engine_FRuntimeFloatCurve.h"
#include "M1_FM1StatTypeOpValue.h"
#include "M1_FM1AbilityEventData_WeaponAttack.h"
#include "M1_FM1AbilityEventData_ReconcileDamage.h"
#include "M1_FM1AbilityEventData_PlayerRevive.h"
#include "M1_FM1AbilityEventData_DBNO.h"
#include "M1_FM1AbilityEventData_AnimNotify.h"
#include "M1Actor_ENUMS.h"
#include "M1Data_FM1StatTypeOpFloat.h"
#include "CoreUObject_FSoftObjectPath.h"
#include "Engine_FPredictProjectilePathResult.h"
#include "M1_FM1AbilityProjectilePathPredictionParams_CustomArc.h"
#include "M1_FM1AbilityProjectilePathDebugDrawParams.h"
#include "M1_FM1AbilityEventData.h"
#include "CoreUObject_FBox.h"
#include "M1_FM1MotionBlurCameraSetting.h"
#include "M1Data_FM1AbilityParamData.h"
#include "M1_FM1AbilityContextHandle.h"

// --------------------------------------------------
// # Forwards
// --------------------------------------------------
namespace CG::CoreUObject { class UObject; };
namespace CG::Engine { class AActor; };
namespace CG::M1 { class UM1Ability; };
namespace CG::M1 { class UM1DataVisualFX; };
namespace CG::M1 { class UM1DataPostProcessMaterialEffect; };
namespace CG::Engine { class UAnimMontage; };
namespace CG::Engine { class UShapeComponent; };
namespace CG::M1 { class AM1Player; };
namespace CG::NavigationSystem { class ANavigationData; };
namespace CG::NavigationSystem { class UNavigationQueryFilter; };
namespace CG::Engine { class UActorComponent; };
namespace CG::M1 { class UM1SkillAbility; };
namespace CG::M1 { class AM1DestructibleStaticMeshActor; };
namespace CG::Engine { class UCameraShakeBase; };
namespace CG::M1 { class AM1WireCaster; };
namespace CG::Engine { class UAnimInstance; };
namespace CG::Engine { class USkeletalMeshComponent; };
namespace CG::M1 { class AM1Weapon; };
namespace CG::M1 { class AM1Character; };
namespace CG::NavigationSystem { class ARecastNavMesh; };
namespace CG::Engine { class UMeshComponent; };
namespace CG::M1 { class UM1BeamComponent; };
namespace CG::M1 { class UM1DataSoundEffects; };
namespace CG::CoreUObject { class UScriptStruct; };
namespace CG::M1 { class AM1AbilityActor; };
namespace CG::CoreUObject { class UClass; };

#ifdef _MSC_VER
    #pragma pack(push, 0x01)
#endif

namespace CG::M1
{
    /**
     * Class /Script/M1.M1AbilityUtil
     * Size -> 0x0000 (FullSize[0x0028] - InheritedSize[0x0028])
     */
    class UM1AbilityUtil : public Engine::UBlueprintFunctionLibrary
    {
    public:
        CoreUObject::FVector STATIC_ZeroRebaseVec(CoreUObject::UObject* WorldContextObject, const CoreUObject::FVector& Loc);
        CoreUObject::FTransform STATIC_ZeroRebaseTrans(CoreUObject::UObject* WorldContextObject, const CoreUObject::FTransform& Trans);
        Engine::FHitResult STATIC_ZeroRebaseHit(CoreUObject::UObject* WorldContextObject, const Engine::FHitResult& Hit);
        bool STATIC_WillDieTakeDamage(Engine::AActor* Actor, bool bForcedReduceHP, const M1Data::FM1ScaledInteger& TotalDamage, M1Data::FM1ScaledInteger* OutAppliedDamage);
        bool STATIC_WasPlayerStateReady(Engine::AActor* Actor);
        bool STATIC_ValidateClientLocations(Engine::AActor* Owner, BasicTypes::TArray<CoreUObject::FVector> ClientLocations, float ExtentValidationSize);
        bool STATIC_ValidateClientLocation(Engine::AActor* Owner, const CoreUObject::FVector& ClientLocation, float ExtentValidationSize);
        void STATIC_UpdateStatusEffectStackCount(Engine::AActor* Actor, const M1::FM1AbilityId& StatusEffectId, int32_t Delta);
        void STATIC_UnregisterPickupWeapon(M1::UM1Ability* Ability);
        void STATIC_UnapplyWeaponModifierSetInfo(Engine::AActor* Actor, const BasicTypes::FName& WeaponModSetName);
        void STATIC_UnapplyVFXAll(Engine::AActor* Actor, bool Immediately);
        void STATIC_UnapplyVFX(Engine::AActor* Actor, M1::UM1DataVisualFX* VFXAsset, bool Immediately);
        void STATIC_UnapplyPPMaterialEffect(Engine::AActor* Actor, M1::UM1DataPostProcessMaterialEffect* EffectAsset);
        void STATIC_UnapplyPlayerAbilityUpperBodyLayer(Engine::AActor* Actor);
        void STATIC_UnapplyPlayerAbilityLocomotionLayer(Engine::AActor* Actor);
        void STATIC_UnapplyCharacterRootMotion(Engine::AActor* Actor);
        void STATIC_UnapplyCameraMortionBlurSetting(Engine::AActor* Actor);
        M1::UM1DataVisualFX* STATIC_TryLoadVFXData(const BasicTypes::FName& VFXAssetName);
        Engine::UAnimMontage* STATIC_TryLoadMontage(const BasicTypes::FName& MontageName);
        bool STATIC_TryApplyDestructivePower(const M1::FM1AbilityOpCalcParam& Param, M1::FM1CalcDamageInfo* DamageInfo);
        void STATIC_TransferDamage(Engine::AActor* Target, const M1::FM1CalcDamageInfo& DamageInfo, float HpTransferRate);
        void STATIC_SyncWeaponChangingByServer(M1::UM1Ability* Ability, M1Data::EM1EquipmentSlotType InFromWeaponSlot, M1Data::EM1EquipmentSlotType InToWeaponSlot);
        CoreUObject::FVector STATIC_SuggestVelocityByLocations(CoreUObject::UObject* WorldContextObject, const CoreUObject::FVector& StartLocation, const CoreUObject::FVector& EndLocation, BasicTypes::TArray<Engine::AActor*> ActorsToIgnore, float LaunchSpeed, float GravityScale, bool bDebugDraw);
        void STATIC_ShowEciveMarker(Engine::AActor* Target);
        bool STATIC_ShapeTraceTerrain(CoreUObject::UObject* WorldContextObject, Engine::UShapeComponent* ShapeComp, const CoreUObject::FVector& Start, const CoreUObject::FVector& End, const CoreUObject::FRotator& Rot, bool bTraceComplex, Engine::FHitResult* OutHit);
        bool STATIC_ShapeTrace(CoreUObject::UObject* WorldContextObject, Engine::UShapeComponent* ShapeComp, const CoreUObject::FVector& Start, const CoreUObject::FVector& End, const CoreUObject::FRotator& Rot, Engine::FHitResult* OutHit);
        bool STATIC_SetOwnerWeaponSlotHidden(M1::UM1Ability* Ability, M1Data::EM1EquipmentSlotType EquipmentSlot, bool bHidden);
        void STATIC_SetOwnerWeaponHidden(M1::UM1Ability* Ability, bool bHidden, bool bAllWeapons);
        void STATIC_SetOwnerDisableIHandIK(M1::UM1Ability* Ability, bool bIKDisable);
        void STATIC_SetOwnerDisableFootIK(M1::UM1Ability* Ability, bool bIKDisable);
        M1Data::EM1EquipmentSlotType STATIC_SetOwnerCurrentWeaponSlotHidden(M1::UM1Ability* Ability, bool bHidden);
        void STATIC_SetExtraConsumeRoundsPerFire(M1::UM1Ability* Ability, M1Data::EM1EquipmentSlotType InTargetWeaponSlot, int32_t InExtraConsumeRounds);
        void STATIC_SetDamageOrders(Engine::AActor* Actor, BasicTypes::TArray<M1Data::EM1StatType> Orders);
        void STATIC_SetCurrentWeaponUseAltHitEffects(M1::UM1Ability* Ability, bool bUse);
        void STATIC_SetCurrentWeaponUseAltFireEffect(M1::UM1Ability* Ability, bool bUse);
        void STATIC_SetCurrentWeaponAltHitEffects(M1::UM1Ability* Ability, BasicTypes::TSoftObjectPtr<M1::UM1DataHitEffects> HitEffects);
        void STATIC_SetCurrentWeaponAltFireEffect(M1::UM1Ability* Ability, M1::EM1WeaponFXType FXType, BasicTypes::TSoftObjectPtr<Niagara::UNiagaraSystem> FX);
        void STATIC_SetCarryingContainerHidden(M1::UM1Ability* Ability, bool bHidden);
        void STATIC_SetBlackboardValueAsInt(Engine::AActor* Actor, const BasicTypes::FName& Key, int32_t Value);
        void STATIC_SetBlackboardValueAsBool(Engine::AActor* Actor, const BasicTypes::FName& Key, bool Value);
        void STATIC_SetActorLocalVisibility(Engine::AActor* InActor, bool InbVisible);
        void STATIC_SetActorEnableCollision(Engine::AActor* Owner, bool bEnable, const BasicTypes::FString& InContext);
        void STATIC_SendAbilityEvent(Engine::AActor* Actor, const M1::FM1AbilityEvent& Event);
        M1Data::FM1ScaledInteger STATIC_ScaledIntegerZero();
        M1Data::FM1ScaledInteger STATIC_ScaledIntegerOne();
        M1Data::FM1ScaledInteger STATIC_ScaledIntegerMin(const M1Data::FM1ScaledInteger& A, const M1Data::FM1ScaledInteger& B);
        M1Data::FM1ScaledInteger STATIC_ScaledIntegerMax(const M1Data::FM1ScaledInteger& A, const M1Data::FM1ScaledInteger& B);
        M1Data::FM1ScaledInteger STATIC_ScaledIntegerClamp(const M1Data::FM1ScaledInteger& Value, const M1Data::FM1ScaledInteger& Min, const M1Data::FM1ScaledInteger& Max);
        CoreUObject::FTransform STATIC_RotateToOwnerViewDir(M1::UM1Ability* Ability, const CoreUObject::FTransform& InTransform);
        CoreUObject::FTransform STATIC_RotateToOwnerDir(M1::UM1Ability* Ability, const CoreUObject::FTransform& InTransform);
        CoreUObject::FVector STATIC_RotateDirectionVertical(const CoreUObject::FRotator& InOriginRot, float InRotationAngle);
        CoreUObject::FVector STATIC_RotateDirectionRandom(const CoreUObject::FRotator& InOriginRot, float InDegree);
        CoreUObject::FVector STATIC_RotateDirectionHorizontal(const CoreUObject::FRotator& InOriginRot, float InRotationAngle);
        CoreUObject::FRotator STATIC_RFixedTurn(const CoreUObject::FRotator& InCurrent, const CoreUObject::FRotator& InDesired, float InDeltaRate);
        void STATIC_ResetDamageOrders(Engine::AActor* Actor);
        void STATIC_ResetCurrentWeaponProjectile(Engine::AActor* WeaponOwner);
        void STATIC_ResetCurrentWeapon(M1::UM1Ability* Ability);
        void STATIC_ReplacePlayerActiveSkillCooltime(Engine::AActor* Actor, M1::EM1BattleKey InKey, float InValue);
        void STATIC_RegisterPickupWeapon(M1::UM1Ability* Ability);
        void STATIC_ReducePlayerSkillChargeMaxCount(M1::AM1Player* PC, M1::EM1BattleKey InKey);
        void STATIC_ReducePlayerActiveSkillCooltimeBySelectType(Engine::AActor* Actor, M1::EM1ElementSelectType SelectCooltimeType, float ReduceAmount);
        void STATIC_ReducePlayerActiveSkillCooltimeByMaxRatio(Engine::AActor* Actor, M1::EM1BattleKey InKey, float InRatio);
        bool STATIC_ProjectPointToNavigation(Engine::AActor* Owner, const CoreUObject::FVector& Point, CoreUObject::FVector* ProjectedLocation, NavigationSystem::ANavigationData* NavData, NavigationSystem::UNavigationQueryFilter* FilterClass, const CoreUObject::FVector& QueryExtent);
        bool STATIC_PredictPathCustomArc(Engine::AActor* SelfActor, const CoreUObject::FVector& StartLocation, const CoreUObject::FVector& TargetLocation, float ArcValue, BasicTypes::TArray<Engine::FPredictProjectilePathPointData>* OutPathData, bool bDebugDraw);
        void STATIC_PauseTargetChangeForDuration(Engine::AActor* Actor, bool bPause, float Duration);
        void STATIC_Montage_JumpToSection(Engine::AActor* InActor, const BasicTypes::FName& InSectionName, Engine::UAnimMontage* InMontage);
        void STATIC_ModifyPlayerActiveSkillCooltime(Engine::AActor* Actor, M1::EM1BattleKey InKey, M1Data::EM1StatModifierOp InModOp, float InValue);
        M1::FM1AbilityTargetInfoHandle STATIC_MakeTargetInfoFromHitResult(const Engine::FHitResult& InHitResult);
        M1::FM1AbilityTargetInfoHandle STATIC_MakeTargetInfoFromActorArray(BasicTypes::TArray<Engine::AActor*> ActorArray);
        M1::FM1AbilityTargetInfoHandle STATIC_MakeTargetInfoFromActor(Engine::AActor* Actor);
        M1::FM1AbilityOperationParam STATIC_MakeOperationParamFromHitComponent(Engine::UActorComponent* HitComp);
        M1::FM1CalcDamageInfo STATIC_MakeCalcDamageInfo(const M1::FM1AbilityOpCalcParam& Param);
        M1::FM1AbilityEventDataHandle STATIC_MakeAbilityEventData_WeaponSlotType(const M1::FM1AbilityEventData_WeaponSlotType& Data);
        M1::FM1AbilityEventDataHandle STATIC_MakeAbilityEventData_DamageInfo(const M1::FM1AbilityEventData_DamageInfo& Data);
        M1::FM1AbilityEventDataHandle STATIC_MakeAbilityEventData_DamageCalculation(const M1::FM1AbilityEventData_DamageCalculation& Data);
        CoreUObject::FVector STATIC_LocalRebaseVec(CoreUObject::UObject* WorldContextObject, const CoreUObject::FVector& Loc);
        CoreUObject::FTransform STATIC_LocalRebaseTrans(CoreUObject::UObject* WorldContextObject, const CoreUObject::FTransform& Trans);
        Engine::FHitResult STATIC_LocalRebaseHit(CoreUObject::UObject* WorldContextObject, const Engine::FHitResult& Hit);
        void STATIC_Local_FlushServerMoves(Engine::AActor* Actor);
        bool STATIC_LineTraceToPlayerAim(M1::AM1Player* Player, const CoreUObject::FVector& StartLoc, float TraceLength, Engine::ECollisionChannel TraceChannel, bool bCheckValidTarget, bool bTraceComplex, BasicTypes::TArray<Engine::FHitResult>* OutHits);
        bool STATIC_LineTraceTerrain(CoreUObject::UObject* WorldContextObject, const CoreUObject::FVector& Start, const CoreUObject::FVector& End, bool bTraceComplex, Engine::FHitResult* OutHit);
        bool STATIC_IsWithCheat();
        bool STATIC_IsWalkableFloor(Engine::AActor* Owner, const CoreUObject::FVector& CapsuleLocation);
        bool STATIC_IsValidTargetInfo(const M1::FM1AbilityTargetInfoHandle& TargetInfo);
        bool STATIC_IsValidTags(const GameplayTags::FGameplayTagContainer& TagContainer);
        bool STATIC_IsValidTag(const GameplayTags::FGameplayTag& Tag);
        bool STATIC_IsValid(const M1::FM1IntegerId& InId);
        bool STATIC_IsTargetInConeAOE(Engine::AActor* SelfActor, Engine::AActor* TargetActor, const CoreUObject::FTransform& FireTransform, float Range, float ThetaDegree, bool bDebugDrawCone);
        bool STATIC_IsStrengthenedSkill(M1::UM1SkillAbility* InSkillAbility);
        bool STATIC_IsMissionObjectDestroyed(Engine::AActor* MissionObject);
        bool STATIC_IsInSquad(Engine::AActor* Actor);
        bool STATIC_IsInSameSquad(Engine::AActor* Actor, Engine::AActor* OtherActor);
        bool STATIC_IsInCylidricalSector(const CoreUObject::FVector& TestLocation, const CoreUObject::FVector& OriginLocation, const CoreUObject::FVector& ForwardDirection, float RadiusMin, float RadiusMax, float HeightDiffLow, float HeightDiffHigh, float FullAngleDeg, float ErrorLimit);
        bool STATIC_IsInCircularSectorXY(const CoreUObject::FVector& TestLocation, const CoreUObject::FVector& OriginLocation, const CoreUObject::FVector& ForwardDirection, float RadiusMin, float RadiusMax, float FullAngleDeg, float ErrorLimit);
        bool STATIC_IsGaugeStatFull(Engine::AActor* Actor, M1Data::EM1StatType GaugeStatType);
        bool STATIC_IsEnableShowEciveMarker(Engine::AActor* Target);
        bool STATIC_IsDestructed(M1::AM1DestructibleStaticMeshActor* DestructibleMeshActor);
        bool STATIC_IsCurrentWeaponZoomed(M1::UM1Ability* Ability);
        bool STATIC_IsActiveTag(Engine::AActor* Actor, const GameplayTags::FGameplayTag& Tag);
        bool STATIC_IsActiveStatusEffectIdTags(Engine::AActor* Actor, const GameplayTags::FGameplayTagContainer& InTags);
        bool STATIC_IsActiveStatusEffectIdTag(Engine::AActor* Actor, const GameplayTags::FGameplayTag& Tag);
        bool STATIC_IsActiveStatusEffect(Engine::AActor* Actor, const M1::FM1AbilityId& ID);
        void STATIC_InvokeCameraShake(Engine::AActor* OriginActor, Engine::UCameraShakeBase* CameraShake, float ApplyRadius);
        void STATIC_InitializeWeaponRounds(M1::UM1Ability* Ability, M1Data::EM1EquipmentSlotType InTargetWeaponSlot, int32_t InRounds);
        void STATIC_InitializeGaugeStats(Engine::AActor* Actor);
        void STATIC_InitializeGaugeStat(Engine::AActor* Actor, M1Data::EM1StatType InStatType);
        bool STATIC_HasTraitTagFromSkillCommitedEvent(const M1::FM1AbilityEvent& InEvent, const GameplayTags::FGameplayTag& InTraitTag);
        bool STATIC_HasTraitTagFromSkillActivatedEvent(const M1::FM1AbilityEvent& InEvent, const GameplayTags::FGameplayTag& InTraitTag);
        bool STATIC_HasTraitTagFromDamageInfoEvent(const M1::FM1AbilityEvent& InEvent, const GameplayTags::FGameplayTag& InTraitTag);
        bool STATIC_HasAnyMatchingTags(Engine::AActor* Actor, const GameplayTags::FGameplayTagContainer& TagContainer);
        M1::AM1WireCaster* STATIC_GetWireCaster(Engine::AActor* WireOwner);
        M1Data::EM1RoundsType STATIC_GetWeaponCurrentRoundsType(M1::UM1Ability* Ability);
        int32_t STATIC_GetWeaponCurrentRounds(M1::UM1Ability* Ability, M1Data::EM1EquipmentSlotType InTargetWeaponSlot);
        Engine::ETraceTypeQuery STATIC_GetTerrainCollisionChannel();
        CoreUObject::FVector STATIC_GetTaggedVectorVariantFrom(Engine::AActor* Actor, const GameplayTags::FGameplayTag& Tag, const BasicTypes::FName& VariantName);
        int32_t STATIC_GetTaggedIntVariantFrom(Engine::AActor* Actor, const GameplayTags::FGameplayTag& Tag, const BasicTypes::FName& VariantName);
        float STATIC_GetTaggedFloatVariantFrom(Engine::AActor* Actor, const GameplayTags::FGameplayTag& Tag, const BasicTypes::FName& VariantName);
        bool STATIC_GetTaggedBoolVariantFrom(Engine::AActor* Actor, const GameplayTags::FGameplayTag& Tag, const BasicTypes::FName& VariantName);
        PhysicsCore::EPhysicalSurface STATIC_GetSurfaceType(Engine::AActor* InActor);
        float STATIC_GetSubSkillTargetDetectRectYRatio();
        float STATIC_GetSubSkillTargetDetectRectXRatio();
        bool STATIC_GetStatValue(Engine::AActor* Actor, M1Data::EM1StatType StatType, M1Data::FM1ScaledInteger* StatValue);
        BasicTypes::FString STATIC_GetStatEnumString(M1Data::EM1StatType StatType);
        float STATIC_GetStateMachineStateAnimLength(Engine::AActor* Actor, const BasicTypes::FName& MachineName, const BasicTypes::FName& StateName, BasicTypes::TArray<Engine::UAnimInstance*> LayerClasses, const BasicTypes::FName& SubAnimInstTag, const CoreUObject::FVector& BlendInput);
        BasicTypes::TArray<M1::AM1Player*> STATIC_GetSquadPlayers(Engine::AActor* Actor, bool bIncludeSelf);
        Engine::AActor* STATIC_GetRootActor(Engine::AActor* Actor);
        M1Data::FM1ScaledInteger STATIC_GetRefStatByDesc(const M1::FM1AbilityOpCalcParam& Param, const M1::FM1StatRefDesc& StatRefDesc);
        M1Data::FM1ScaledInteger STATIC_GetRefStat(const M1::FM1AbilityOpCalcParam& Param, M1Data::EM1StatType StatType, M1Data::EM1StatRefType StatRefType, bool bIgnoreOverride);
        bool STATIC_GetRandomTeleportLocationInNavMesh(Engine::AActor* InActor, const CoreUObject::FVector& OriginLocation, CoreUObject::FVector* OutRandomLocation, float RadiusMin, float RadiusMax, float TeleportMaxHeight);
        int32_t STATIC_GetPlayerSkillRemainingChargeCount(M1::AM1Player* PC, M1::EM1BattleKey InKey);
        M1Data::FM1ScaledInteger STATIC_GetPlayerDEFInflectionVar(int32_t VarNum);
        M1Data::FM1ScaledInteger STATIC_GetPlayerAttackerLevelCnst(int32_t PlayerWeaponLevel);
        M1::EM1PlayerAnimType STATIC_GetPlayerAnimType(Engine::AActor* Actor);
        M1Data::EM1CharacterGender STATIC_GetPlayerAnimPresetType(Engine::AActor* Actor);
        bool STATIC_GetPlayerActiveSkillRemainingCooltime(Engine::AActor* Actor, M1::EM1BattleKey InKey, float* OutRemainCoolTime);
        bool STATIC_GetPlayerActiveSkillCooltime(Engine::AActor* Actor, M1::EM1BattleKey InKey, float* OutCoolTime);
        M1::UM1SkillAbility* STATIC_GetPlayerActiveSkillAbility(Engine::AActor* Actor, M1::EM1BattleKey InKey);
        void STATIC_GetPhysicalVelocityFromDamageCauser(Engine::AActor* InDamagedActor, const M1::FM1CalcDamageInfo& InDamageInfo, bool* bOutValidVelocity, CoreUObject::FVector* OutVelocity);
        CoreUObject::FTransform STATIC_GetOwnerSocketTransform(M1::UM1Ability* Ability, const BasicTypes::FName& SocketName);
        float STATIC_GetOwnerRadius(M1::UM1Ability* Ability);
        CoreUObject::FVector STATIC_GetOwnerLocation(M1::UM1Ability* Ability);
        float STATIC_GetOwnerHalfHeight(M1::UM1Ability* Ability);
        CoreUObject::FVector STATIC_GetOwnerFeetLocation(M1::UM1Ability* Ability);
        BasicTypes::TArray<M1::FM1NormalMonsterHitReactionData> STATIC_GetNormalMonsterHitReactionData(Engine::AActor* Actor);
        Engine::AActor* STATIC_GetNamedActorFromTargetInfo(const M1::FM1AbilityTargetInfoHandle& TargetInfo, const BasicTypes::FName& Name);
        M1Data::FM1ScaledInteger STATIC_GetMonsterInitMaxHP(const M1::FM1AbilityOpCalcParam& Param, const BasicTypes::FName& VariantNameInitMaxHP);
        M1Data::FM1ScaledInteger STATIC_GetMonsterDEFInflectionVar(int32_t VarNum);
        M1Data::EM1MonsterCategory STATIC_GetMonsterCategoryFromOpTarget(const M1::FM1AbilityOpCalcParam& Param);
        M1Data::EM1MonsterCategory STATIC_GetMonsterCategory(Engine::AActor* Target);
        M1Data::FM1ScaledInteger STATIC_GetMonsterAttackerLevelCnst(int32_t MonsterLevel);
        float STATIC_GetLoopMontageTotalDuration(Engine::UAnimMontage* InMontage, int32_t LoopCount);
        BasicTypes::TArray<CoreUObject::FVector> STATIC_GetLocationsOnArcXY(const CoreUObject::FVector& OriginLocation, const CoreUObject::FVector& ForwardDirection, float Radius, float FullAngleDeg, float DisplacementLength);
        BasicTypes::TArray<CoreUObject::FVector> STATIC_GetLocationsInCircularSectorByGridXY(const CoreUObject::FVector& OriginLocation, const CoreUObject::FVector& ForwardDirection, float RadiusMin, float RadiusMax, float FullAngleDeg, float DisplacementLength, float ErrorLimit, bool bIncludeFarArcExplicitly, bool bIncludeNearArcExplicitly);
        CoreUObject::FVector STATIC_GetLocalPlayerDesiredMoveDir(M1::UM1Ability* OwningAbility);
        M1Data::EM1LegionCategory STATIC_GetLegionCategoryFromOpTarget(const M1::FM1AbilityOpCalcParam& Param);
        M1Data::EM1LegionCategory STATIC_GetLegionCategory(Engine::AActor* Target);
        M1Data::EM1EquipmentSlotType STATIC_GetLastItemWeaponSlotType(M1::UM1Ability* Ability);
        float STATIC_GetInputAxisValue(M1::UM1Ability* Ability, const BasicTypes::FName& InInputAxis);
        Engine::FHitResult STATIC_GetHitResultFromTargetInfo(const M1::FM1AbilityTargetInfoHandle& TargetInfo, int32_t Index, bool* bHasHitResult);
        float STATIC_GetGaugeStatRatio(Engine::AActor* Actor, M1Data::EM1StatType StatType);
        float STATIC_GetFloatValueFromRuntimeCurve(const Engine::FRuntimeFloatCurve& InCurve, float InTime);
        Engine::AActor* STATIC_GetFirstTargetActor(M1::UM1Ability* Ability);
        Engine::AActor* STATIC_GetFirstActorFromTargetInfo(const M1::FM1AbilityTargetInfoHandle& TargetInfo);
        M1Data::FM1ScaledInteger STATIC_GetElementScaleConst();
        M1Data::FM1ScaledInteger STATIC_GetElementLimitConst();
        float STATIC_GetEciveSoundActionTypeSearchAngle();
        float STATIC_GetEciveSearchRemainTime();
        int32_t STATIC_GetEciveSearchMaxCountObject();
        int32_t STATIC_GetEciveSearchMaxCountMoster();
        float STATIC_GetEciveSearchDistanceByType(M1Data::EM1EciveActionType InEciveActionType);
        M1Data::FM1ScaledInteger STATIC_GetDEFScaleConst();
        M1Data::FM1ScaledInteger STATIC_GetDEFLimitConst();
        CoreUObject::FVector STATIC_GetDamageDirection(const M1::FM1CalcDamageInfo& InDamageInfo);
        BasicTypes::TArray<M1::FM1StatTypeOpValue> STATIC_GetDamageCalculationModifiersFromEventData(const M1::FM1AbilityEventDataHandle& EventData);
        M1Data::EM1EquipItemClassType STATIC_GetCurrentWeaponType(Engine::AActor* WeaponOwner, bool InbExcludeAltWeapon);
        M1Data::EM1EquipmentSlotType STATIC_GetCurrentWeaponSlotType(M1::UM1Ability* Ability);
        Engine::USkeletalMeshComponent* STATIC_GetCurrentWeaponMesh(Engine::AActor* WeaponOwner);
        BasicTypes::FName STATIC_GetCurrentWeaponDataName(Engine::AActor* WeaponOwner, bool InbExcludeAltWeapon);
        M1Data::EM1InputMethod STATIC_GetCurrentInputMethod(M1::UM1Ability* Ability);
        M1Data::EM1EquipItemClassType STATIC_GetCurrentGrabbedWeaponType(Engine::AActor* WeaponOwner, bool InbExcludeAltWeapon);
        M1Data::EM1WeaponInstanceType STATIC_GetCurrentGrabbedWeaponInstanceType(Engine::AActor* WeaponOwner);
        BasicTypes::FName STATIC_GetCurrentGrabbedWeaponDataName(Engine::AActor* WeaponOwner, bool InbExcludeAltWeapon);
        M1::AM1Weapon* STATIC_GetCurrentGrabbedWeapon(M1::UM1Ability* Ability);
        CoreUObject::FRotator STATIC_GetControllerRotation(Engine::AActor* Owner);
        CoreUObject::FRotator STATIC_GetCameraRotation(M1::UM1Ability* OwningAbility);
        CoreUObject::FVector STATIC_GetCameraLocation(M1::UM1Ability* OwningAbility);
        int32_t STATIC_GetBlackboardValueAsInt(Engine::AActor* Actor, const BasicTypes::FName& Key);
        bool STATIC_GetBlackboardValueAsBool(Engine::AActor* Actor, const BasicTypes::FName& Key);
        int32_t STATIC_GetBerserkEntranceCount(Engine::AActor* Target);
        CoreUObject::FVector STATIC_GetAttackBoneLocation(M1::UM1Ability* Ability, const BasicTypes::FName& AttackSocketName);
        float STATIC_GetAnimInstancePropertyAnimLength(Engine::AActor* Actor, const BasicTypes::FName& AnimPropertyName);
        float STATIC_GetAnimInstanceMontageSectionLength(Engine::UAnimMontage* InMontage, const BasicTypes::FName& SectionName);
        BasicTypes::TArray<float> STATIC_GetAnimInstanceArrayPropertyAnimLengths(Engine::AActor* Actor, const BasicTypes::FName& ArrayPropertyName);
        float STATIC_GetAnimInstanceArrayPropertyAnimLength(Engine::AActor* Actor, const BasicTypes::FName& ArrayPropertyName, int32_t Index);
        void STATIC_GetAllInteractableActorByEciveType(Engine::AActor* InActor, const CoreUObject::FVector& CameraLocation, BasicTypes::TArray<Engine::AActor*>* OutActors, M1Data::EM1EciveActionType InEciveActionType);
        BasicTypes::TArray<Engine::AActor*> STATIC_GetAllActorsFromTargetInfo(const M1::FM1AbilityTargetInfoHandle& TargetInfo);
        M1::AM1Character* STATIC_GetAimedCharacter(M1::AM1Player* InSrcPlayer, float InMaxDistance, M1Data::EM1RelationsCheckType InRelationsCheck, bool InbOnlyAlive);
        float STATIC_GetAimAOPitch(Engine::AActor* Actor);
        CoreUObject::FTransform STATIC_GetActorSocketTransform(Engine::AActor* Actor, const BasicTypes::FName& SocketName);
        BasicTypes::TArray<Engine::AActor*> STATIC_GetActorsFromTargetInfo(const M1::FM1AbilityTargetInfoHandle& TargetInfo, int32_t Index);
        NavigationSystem::ARecastNavMesh* STATIC_GetActorNavData(Engine::AActor* InActor);
        CoreUObject::FVector STATIC_GetActorLocationFromTargetInfo(const M1::FM1AbilityTargetInfoHandle& TargetInfo);
        CoreUObject::FVector STATIC_GetActorAttackBoneLocation(Engine::AActor* Actor, const BasicTypes::FName& AttackSocketName);
        int32_t STATIC_GetActiveStatusEffectStackCount(Engine::AActor* Actor, const M1::FM1AbilityId& StatusEffectId);
        int32_t STATIC_GetActiveStatusEffectMaxStackCount(Engine::AActor* Actor, const M1::FM1AbilityId& StatusEffectId);
        M1::FM1AbilityEventData_WeaponSlotType STATIC_GetAbilityEventData_WeaponSlotType(const M1::FM1AbilityEventDataHandle& EventData);
        M1::FM1AbilityEventData_WeaponAttack STATIC_GetAbilityEventData_WeaponAttack(const M1::FM1AbilityEventDataHandle& EventData);
        M1::FM1AbilityEventData_ReconcileDamage STATIC_GetAbilityEventData_ReconcileDamage(const M1::FM1AbilityEventDataHandle& EventData);
        M1::FM1AbilityEventData_PlayerRevive STATIC_GetAbilityEventData_PlayerRevive(const M1::FM1AbilityEvent& Event);
        M1::FM1AbilityEventData_DBNO STATIC_GetAbilityEventData_DBNO(const M1::FM1AbilityEventDataHandle& EventData);
        M1::FM1AbilityEventData_DamageInfo STATIC_GetAbilityEventData_DamageInfo(const M1::FM1AbilityEventDataHandle& EventData);
        M1::FM1AbilityEventData_DamageCalculation STATIC_GetAbilityEventData_DamageCalculation(const M1::FM1AbilityEventDataHandle& EventData);
        M1::FM1AbilityEventData_AnimNotify STATIC_GetAbilityEventData_AnimNotify(const M1::FM1AbilityEventDataHandle& EventData);
        M1Data::FM1ScaledInteger STATIC_FromInt(int32_t InValue);
        M1Data::FM1ScaledInteger STATIC_FromFloat(float InValue);
        M1Data::FM1ScaledInteger STATIC_FromDouble(double InValue);
        void STATIC_Floor(uint8_t DecimalPointPlace, M1Data::FM1ScaledInteger* ScaledInteger);
        bool STATIC_FindSphereOverlapActors(BasicTypes::TArray<Engine::AActor*>* OutActors, M1::UM1Ability* Ability, const CoreUObject::FVector& OverlapLocationOffset, float SphereRadius, M1Data::EM1RelationsCheckType RelationCheckType, const GameplayTags::FGameplayTag& QueryTag, bool bCheckValidTarget);
        CoreUObject::FVector STATIC_FindNavGround(Engine::AActor* Owner, const CoreUObject::FVector& InLocation);
        Engine::UAnimMontage* STATIC_FindNamedMontage(Engine::AActor* Actor, const BasicTypes::FName& MontageName);
        bool STATIC_FindGround(CoreUObject::UObject* WorldContextObject, const CoreUObject::FVector& OriginLocation, bool bTraceComplex, BasicTypes::TArray<Engine::AActor*> IgnoreActors, CoreUObject::FVector* OutLocation, bool bReverse, bool bTryViceVersa);
        Engine::UMeshComponent* STATIC_FindCustomizingSkinComponent(Engine::AActor* Actor, M1::EM1CharacterMeshSlotType InType);
        bool STATIC_FindBoxOverlapActors(BasicTypes::TArray<Engine::AActor*>* OutActors, M1::UM1Ability* Ability, const CoreUObject::FVector& OverlapLocationOffset, const CoreUObject::FVector& BoxHalfExtent, M1Data::EM1RelationsCheckType RelationCheckType, const GameplayTags::FGameplayTag& QueryTag, bool bCheckValidTarget);
        CoreUObject::FTransform STATIC_ExtractAnimMontageRootMotionFromSection(Engine::UAnimMontage* InMontage, const BasicTypes::FName& SectionName);
        void STATIC_EquipAltWeapon(M1::UM1Ability* Ability, const BasicTypes::FName& AltWeaponName);
        void STATIC_EnableAnimPhys(Engine::USkeletalMeshComponent* SkelMesh);
        M1::UM1BeamComponent* STATIC_DuplicateBeamComponent(Engine::AActor* Target, M1::UM1BeamComponent* Source, const BasicTypes::FName& Name);
        void STATIC_DisableSmoothPelvisOffsetZ(Engine::AActor* Actor, bool bDisable);
        void STATIC_DisableAnimPhys(Engine::USkeletalMeshComponent* SkelMesh, M1Actor::EM1AnimPhysDisabledState DesiredState);
        void STATIC_DeactivateAltWeapon(M1::UM1Ability* Ability);
        bool STATIC_ConvertGaugeStatType_MaxToCurrent(M1Data::EM1StatType InMaxStatType, M1Data::EM1StatType* OutCurrStatType);
        bool STATIC_ConvertGaugeStatType_CurrentToMax(M1Data::EM1StatType InCurrStatType, M1Data::EM1StatType* OutMaxStatType);
        void STATIC_ClearPlayerSkillCooltime(M1::AM1Player* InPlayer);
        void STATIC_ClearPlayerActiveSkillCurrentStackChargingTime(Engine::AActor* Actor, M1::EM1BattleKey InKey);
        void STATIC_ClearPlayerActiveSkillCooltimeBySelectType(Engine::AActor* Actor, M1::EM1ElementSelectType SelectCooltimeType);
        void STATIC_ClearPlayerActiveSkillCooltime(Engine::AActor* Actor, M1::EM1BattleKey InKey);
        CoreUObject::FVector STATIC_ClampLocationWithinActorView(Engine::AActor* Actor, const CoreUObject::FVector& TargetLocation, float YawMin, float YawMax);
        bool STATIC_CheckPlayerPassiveSkillCoolTime(Engine::AActor* Actor, int32_t Index);
        bool STATIC_CheckPlayerActiveSkillCoolTime(Engine::AActor* Actor, M1::EM1BattleKey InKey);
        bool STATIC_CheatIsDebugDrawHitArea();
        bool STATIC_CheatIsAbilityDrawDebug();
        void STATIC_CheatExecuteStatsToTarget(Engine::AActor* InTarget, BasicTypes::TArray<M1Data::FM1StatTypeOpFloat> Stats);
        void STATIC_CheatAddTagToTarget(Engine::AActor* InTarget, const GameplayTags::FGameplayTag& Tag);
        void STATIC_ChangeWeaponHitEffects(M1::UM1Ability* InAbility, M1Data::EM1EquipmentSlotType InTargetWeaponSlot, const CoreUObject::FSoftObjectPath& InHitVFXEffectsDataPath, M1::UM1DataSoundEffects* InHitSoundsEffects);
        void STATIC_ChangeCurrentWeaponProjectile(Engine::AActor* WeaponOwner, const BasicTypes::FName& InProjectileRowName);
        bool STATIC_CanPlayPlayerHitReaction(Engine::AActor* Actor);
        bool STATIC_CanChangeWithAltWeapon(Engine::AActor* WeaponOwner);
        void STATIC_CancelStatusEffectByIdTag(Engine::AActor* Actor, const GameplayTags::FGameplayTagContainer& InTags);
        void STATIC_CalculationLog(const M1::FM1AbilityOpCalcParam& Param, const BasicTypes::FString& Log);
        CoreUObject::FVector STATIC_CalculateVelocityCustomArc(Engine::AActor* SelfActor, const CoreUObject::FVector& StartLocation, const CoreUObject::FVector& TargetLocation, float ArcValue, bool bDebugDraw);
        BasicTypes::TArray<CoreUObject::FVector> STATIC_CalculateSprayDirections(const CoreUObject::FRotator& AbilityActorRotation, int32_t SpawnCount, float SprayDegree, M1Data::EM1ProjectileAlignmentType SprayType);
        CoreUObject::FVector STATIC_CalcRandomPointInCircle(const CoreUObject::FVector& TargetLocation, float CircleRadius);
        bool STATIC_CalcProjectileSpawnTransform(M1::UM1Ability* OwningAbility, const GameplayTags::FGameplayTagContainer& InTags, const CoreUObject::FVector& SocketLocation, float VelocityAndRangeMultiplier, CoreUObject::FTransform* OutTransform);
        void STATIC_CalcAimDirAndFireLoc(M1::UM1Ability* Ability, const BasicTypes::FName& FireSocketName, const BasicTypes::FName& AxisSocketName, const BasicTypes::FName& AttackBoneName, CoreUObject::FVector* AimDir, CoreUObject::FVector* FireLocation);
        void STATIC_BP_SuggestVelocityAndPredictPath_CustomArc(bool* bOutSuggested, bool* bOutPredicted, CoreUObject::FVector* OutInitialVelocity, Engine::FPredictProjectilePathResult* OutPathPredictionResult, Engine::AActor* SelfActor, const M1::FM1AbilityProjectilePathPredictionParams_CustomArc& Params, const M1::FM1AbilityProjectilePathDebugDrawParams& DebugDrawParams);
        M1::FM1AbilityEventDataHandle STATIC_BP_MakeAbilityEventData(int32_t InEventData);
        void STATIC_BP_GetAbilityEventData(const M1::FM1AbilityEvent& InEvent, CoreUObject::UScriptStruct* EventDataStruct, M1::FM1AbilityEventData* OutEventData);
        bool STATIC_Auth_IsInSameParty(Engine::AActor* Actor, Engine::AActor* OtherActor);
        bool STATIC_Auth_IsInParty(Engine::AActor* Actor);
        BasicTypes::TArray<M1::AM1Player*> STATIC_Auth_GetPartyPlayers(Engine::AActor* Actor, bool bIncludeSelf);
        void STATIC_Auth_DropInstantUseItemByAbilityActor(M1::AM1AbilityActor* AbilityActor, BasicTypes::TArray<M1::AM1Character*> Players, const BasicTypes::FName& InDropItemRowName, const CoreUObject::FVector& AdditionalLocationOffset, const CoreUObject::FBox& DesiredContainerBounds);
        void STATIC_Auth_DropInstantUseItemByAbility(M1::UM1Ability* Ability, BasicTypes::TArray<M1::AM1Character*> Players, const BasicTypes::FName& InDropItemRowName, const CoreUObject::FVector& AdditionalLocationOffset, const CoreUObject::FBox& DesiredContainerBounds);
        void STATIC_ApplyWeaponModifierSetInfo(Engine::AActor* Actor, const BasicTypes::FName& WeaponModSetName, BasicTypes::TArray<M1::FM1StatTypeOpValue> StatModifierDesc);
        void STATIC_ApplyVFX(Engine::AActor* Actor, M1::UM1DataVisualFX* VFXAsset);
        void STATIC_ApplyRotationRateScale(Engine::AActor* Actor, float InScale, float InDuration);
        void STATIC_ApplyReconcileDamage(const M1::FM1AbilityEventDataHandle& EventData, const M1Data::FM1ScaledInteger& ReconciledDamage);
        CoreUObject::FVector STATIC_ApplyRandomSpread(const CoreUObject::FVector& AimDir, int32_t SpreadSize);
        void STATIC_ApplyPPMaterialEffect(Engine::AActor* Actor, M1::UM1DataPostProcessMaterialEffect* EffectAsset);
        void STATIC_ApplyPlayerAbilityUpperBodyLayer(Engine::AActor* Actor, Engine::UAnimInstance* InClass);
        void STATIC_ApplyPlayerAbilityLocomotionLayer(Engine::AActor* Actor, Engine::UAnimInstance* InClass);
        void STATIC_ApplyPauseRotationOnly(Engine::AActor* Actor, bool InApply);
        void STATIC_ApplyPauseMoveAndAnim(Engine::AActor* Actor, bool InApply);
        void STATIC_ApplyPauseMove(Engine::AActor* Actor, bool InApply);
        void STATIC_ApplyOwnerCollisionOverlapPawn(M1::UM1Ability* Ability, bool InApply);
        void STATIC_ApplyMovementSpeed(Engine::AActor* Actor, float Speed);
        void STATIC_ApplyMovementMode(Engine::AActor* Actor, Engine::EMovementMode MovementMode, bool InApply);
        void STATIC_ApplyDisableGenerateOverlapEvent(Engine::AActor* Actor, bool InApply);
        void STATIC_ApplyDamageToTarget(const M1::FM1AbilityOpCalcParam& Param, M1::FM1CalcDamageInfo* DamageInfo);
        void STATIC_ApplyCharacterRootMotion(Engine::AActor* Actor);
        void STATIC_ApplyCameraMortionBlurSetting(Engine::AActor* Actor, const M1::FM1MotionBlurCameraSetting& Setting);
        void STATIC_AppendDamageCalculationModifiersFromOperationsByTags(M1::UM1Ability* Ability, const M1::FM1AbilityEventDataHandle& InOutEventData, const GameplayTags::FGameplayTagContainer& Tags, const M1::FM1AbilityOperationParam& OpParam);
        void STATIC_AddWeaponRounds(M1::UM1Ability* Ability, M1Data::EM1EquipmentSlotType InTargetWeaponSlot, int32_t InRounds, int32_t InMaxRounds);
        void STATIC_AddTaggedVectorVariantTo(Engine::AActor* Actor, const GameplayTags::FGameplayTag& Tag, const BasicTypes::FName& VariantName, const CoreUObject::FVector& Value);
        void STATIC_AddTaggedIntVariantTo(Engine::AActor* Actor, const GameplayTags::FGameplayTag& Tag, const BasicTypes::FName& VariantName, int32_t Value);
        void STATIC_AddTaggedFloatVariantTo(Engine::AActor* Actor, const GameplayTags::FGameplayTag& Tag, const BasicTypes::FName& VariantName, float Value);
        void STATIC_AddTaggedBoolVariantTo(Engine::AActor* Actor, const GameplayTags::FGameplayTag& Tag, const BasicTypes::FName& VariantName, bool Value);
        void STATIC_AddCurrentWeaponAttackAbilityParams(Engine::AActor* WeaponOwner, BasicTypes::TArray<M1Data::FM1AbilityParamData> Params);
        void STATIC_ActivateAltWeapon(M1::UM1Ability* Ability);
        void STATIC_AbilityLog(Engine::AActor* InSource, Engine::AActor* InTarget, const BasicTypes::FString& InLog);
        M1::FM1AbilityContextHandle STATIC_AbilityContextSetTargetInfo(const M1::FM1AbilityContextHandle& Context, const M1::FM1AbilityTargetInfoHandle& TargetInfo);
        BasicTypes::TArray<M1Data::FM1AbilityParamData> STATIC_AbilityContextMakeWeaponParams(M1::AM1Weapon* Weapon);
        M1Data::FM1AbilityParamData STATIC_AbilityContextMakeVectorParam(const BasicTypes::FName& Name, const CoreUObject::FVector& Value);
        M1Data::FM1AbilityParamData STATIC_AbilityContextMakeStrengthenedSkillParam();
        M1Data::FM1AbilityParamData STATIC_AbilityContextMakeBoolParam(const BasicTypes::FName& Name, bool Value);
        bool STATIC_AbilityContextGetVectorParam(const M1::FM1AbilityContextHandle& Context, const BasicTypes::FName& Name, CoreUObject::FVector* OutValue);
        M1::FM1AbilityTargetInfoHandle STATIC_AbilityContextGetTargetInfo(const M1::FM1AbilityContextHandle& Context);
        bool STATIC_AbilityContextGetIntParam(const M1::FM1AbilityContextHandle& Context, const BasicTypes::FName& Name, int32_t* OutValue);
        Engine::AActor* STATIC_AbilityContextGetInstigator(const M1::FM1AbilityContextHandle& Context);
        Engine::AActor* STATIC_AbilityContextGetCauser(const M1::FM1AbilityContextHandle& Context);
        void STATIC_AbilityContextAddParam(const M1::FM1AbilityContextHandle& Context, const M1Data::FM1AbilityParamData& ParamData);
        static inline CoreUObject::UClass* StaticClass()
        {
            static CoreUObject::UClass* ptr = nullptr;
            if (!ptr)
                ptr = CoreUObject::UObject::FindClass("Class /Script/M1.M1AbilityUtil");
            return ptr;
        }
    };
}

#ifdef _MSC_VER
    #pragma pack(pop)
#endif
