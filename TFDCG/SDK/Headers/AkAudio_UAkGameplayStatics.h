#pragma once

/**
 * ----------------------------------------
 * |        Generated By CheatGear        |
 * ----------------------------------------
 * | Game:    TFDCG                       |
 * | Version: 1                           |
 * | Date:    08/22/2024                  |
 * ----------------------------------------
 */

#include <cstdint>
#include <vector>
#include <string>
#include "Engine_UBlueprintFunctionLibrary.h"
#include "BasicTypes_FString.h"
#include "BasicTypes_UScriptDelegate.h"
#include "Engine_FLatentActionInfo.h"
#include "CoreUObject_FVector.h"
#include "CoreUObject_FRotator.h"
#include "BasicTypes_FName.h"
#include "BasicTypes_TArray.h"
#include "AkAudio_ENUMS.h"
#include "CoreUObject_FTransform.h"
#include "AkAudio_FAkChannelMask.h"
#include "AkAudio_FAkOutputSettings.h"
#include "AkAudio_FAkExternalSourceInfo.h"
#include "Engine_ENUMS.h"

// --------------------------------------------------
// # Forwards
// --------------------------------------------------
namespace CG::Engine { class AActor; };
namespace CG::AkAudio { class UAkAuxBus; };
namespace CG::AkAudio { class UAkAudioBank; };
namespace CG::CoreUObject { class UObject; };
namespace CG::AkAudio { class UAkAudioEvent; };
namespace CG::AkAudio { class UAkComponent; };
namespace CG::AkAudio { class UAkSwitchValue; };
namespace CG::AkAudio { class UAkStateValue; };
namespace CG::AkAudio { class UAkRtpc; };
namespace CG::AkAudio { class UAkPortalComponent; };
namespace CG::AkAudio { class UAkTrigger; };
namespace CG::AkAudio { class UAkMediaAsset; };
namespace CG::Engine { class USceneComponent; };
namespace CG::AkAudio { class UAkAudioType; };
namespace CG::CoreUObject { class UClass; };

#ifdef _MSC_VER
    #pragma pack(push, 0x01)
#endif

namespace CG::AkAudio
{
    /**
     * Class /Script/AkAudio.AkGameplayStatics
     * Size -> 0x0000 (FullSize[0x0028] - InheritedSize[0x0028])
     */
    class UAkGameplayStatics : public Engine::UBlueprintFunctionLibrary
    {
    public:
        void STATIC_UseReverbVolumes(bool inUseReverbVolumes, Engine::AActor* Actor);
        void STATIC_UseEarlyReflections(Engine::AActor* Actor, AkAudio::UAkAuxBus* AuxBus, int32_t Order, float BusSendGain, float MaxPathLength, bool SpotReflectors, const BasicTypes::FString& AuxBusName);
        void STATIC_UnloadBankByName(const BasicTypes::FString& BankName);
        void STATIC_UnloadBankAsync(AkAudio::UAkAudioBank* Bank, const BasicTypes::UScriptDelegate& BankUnloadedCallback);
        void STATIC_UnloadBank(AkAudio::UAkAudioBank* Bank, const BasicTypes::FString& BankName, const Engine::FLatentActionInfo& LatentInfo, CoreUObject::UObject* WorldContextObject);
        void STATIC_StopProfilerCapture();
        void STATIC_StopOutputCapture();
        void STATIC_StopAllAmbientSounds(CoreUObject::UObject* WorldContextObject);
        void STATIC_StopAll();
        void STATIC_StopActor(Engine::AActor* Actor);
        void STATIC_StartProfilerCapture(const BasicTypes::FString& Filename);
        void STATIC_StartOutputCapture(const BasicTypes::FString& Filename);
        void STATIC_StartAllAmbientSounds(CoreUObject::UObject* WorldContextObject);
        AkAudio::UAkComponent* STATIC_SpawnAkComponentAtLocation(CoreUObject::UObject* WorldContextObject, AkAudio::UAkAudioEvent* AkEvent, const CoreUObject::FVector& Location, const CoreUObject::FRotator& Orientation, bool AutoPost, const BasicTypes::FString& EventName, bool AutoDestroy);
        void STATIC_SetSwitch(AkAudio::UAkSwitchValue* SwitchValue, Engine::AActor* Actor, const BasicTypes::FName& SwitchGroup, const BasicTypes::FName& SwitchState);
        void STATIC_SetState(AkAudio::UAkStateValue* StateValue, const BasicTypes::FName& StateGroup, const BasicTypes::FName& State);
        void STATIC_SetSpeakerAngles(BasicTypes::TArray<float> SpeakerAngles, float HeightAngle, const BasicTypes::FString& DeviceShareset);
        void STATIC_SetRTPCValue(AkAudio::UAkRtpc* RTPCValue, float Value, int32_t InterpolationTimeMs, Engine::AActor* Actor, const BasicTypes::FName& RTPC);
        void STATIC_SetReflectionsOrder(int32_t Order, bool RefreshPaths);
        void STATIC_SetPortalToPortalObstruction(AkAudio::UAkPortalComponent* PortalComponent0, AkAudio::UAkPortalComponent* PortalComponent1, float ObstructionValue);
        void STATIC_SetPortalObstructionAndOcclusion(AkAudio::UAkPortalComponent* PortalComponent, float ObstructionValue, float OcclusionValue);
        void STATIC_SetPanningRule(AkAudio::EPanningRule PanRule);
        void STATIC_SetOutputBusVolume(float BusVolume, Engine::AActor* Actor);
        void STATIC_SetOcclusionScalingFactor(float ScalingFactor);
        void STATIC_SetOcclusionRefreshInterval(float RefreshInterval, Engine::AActor* Actor);
        void STATIC_SetMultiplePositions(AkAudio::UAkComponent* GameObjectAkComponent, BasicTypes::TArray<CoreUObject::FTransform> Positions, AkAudio::EAkMultiPositionType MultiPositionType);
        void STATIC_SetMultipleChannelMaskEmitterPositions(AkAudio::UAkComponent* GameObjectAkComponent, BasicTypes::TArray<AkAudio::FAkChannelMask> ChannelMasks, BasicTypes::TArray<CoreUObject::FTransform> Positions, AkAudio::EAkMultiPositionType MultiPositionType);
        void STATIC_SetMultipleChannelEmitterPositions(AkAudio::UAkComponent* GameObjectAkComponent, BasicTypes::TArray<AkAudio::EAkChannelConfiguration> ChannelMasks, BasicTypes::TArray<CoreUObject::FTransform> Positions, AkAudio::EAkMultiPositionType MultiPositionType);
        void STATIC_SetGameObjectToPortalObstruction(AkAudio::UAkComponent* GameObjectAkComponent, AkAudio::UAkPortalComponent* PortalComponent, float ObstructionValue);
        void STATIC_SetCurrentAudioCultureAsync(const BasicTypes::FString& AudioCulture, const BasicTypes::UScriptDelegate& Completed);
        void STATIC_SetCurrentAudioCulture(const BasicTypes::FString& AudioCulture, const Engine::FLatentActionInfo& LatentInfo, CoreUObject::UObject* WorldContextObject);
        void STATIC_SetBusConfig(const BasicTypes::FString& BusName, AkAudio::EAkChannelConfiguration ChannelConfiguration);
        void STATIC_ResetRTPCValue(AkAudio::UAkRtpc* RTPCValue, int32_t InterpolationTimeMs, Engine::AActor* Actor, const BasicTypes::FName& RTPC);
        void STATIC_ReplaceMainOutput(const AkAudio::FAkOutputSettings& MainOutputSettings);
        void STATIC_PostTrigger(AkAudio::UAkTrigger* TriggerValue, Engine::AActor* Actor, const BasicTypes::FName& Trigger);
        void STATIC_PostEventByName(const BasicTypes::FString& EventName, Engine::AActor* Actor, bool bStopWhenAttachedToDestroyed);
        int32_t STATIC_PostEventAttached(AkAudio::UAkAudioEvent* AkEvent, Engine::AActor* Actor, const BasicTypes::FName& AttachPointName, bool bStopWhenAttachedToDestroyed, const BasicTypes::FString& EventName);
        void STATIC_PostEventAtLocationByName(const BasicTypes::FString& EventName, const CoreUObject::FVector& Location, const CoreUObject::FRotator& Orientation, CoreUObject::UObject* WorldContextObject);
        int32_t STATIC_PostEventAtLocation(AkAudio::UAkAudioEvent* AkEvent, const CoreUObject::FVector& Location, const CoreUObject::FRotator& Orientation, const BasicTypes::FString& EventName, CoreUObject::UObject* WorldContextObject);
        int32_t STATIC_PostEvent(AkAudio::UAkAudioEvent* AkEvent, Engine::AActor* Actor, int32_t CallbackMask, const BasicTypes::UScriptDelegate& PostEventCallback, BasicTypes::TArray<AkAudio::FAkExternalSourceInfo> ExternalSources, bool bStopWhenAttachedToDestroyed, const BasicTypes::FString& EventName);
        void STATIC_PostAndWaitForEndOfEventAsync(AkAudio::UAkAudioEvent* AkEvent, Engine::AActor* Actor, int32_t* PlayingID, bool bStopWhenAttachedToDestroyed, BasicTypes::TArray<AkAudio::FAkExternalSourceInfo> ExternalSources, const Engine::FLatentActionInfo& LatentInfo);
        int32_t STATIC_PostAndWaitForEndOfEvent(AkAudio::UAkAudioEvent* AkEvent, Engine::AActor* Actor, bool bStopWhenAttachedToDestroyed, BasicTypes::TArray<AkAudio::FAkExternalSourceInfo> ExternalSources, const BasicTypes::FString& EventName, const Engine::FLatentActionInfo& LatentInfo);
        void STATIC_LoadInitBank();
        void STATIC_LoadBanks(BasicTypes::TArray<AkAudio::UAkAudioBank*> SoundBanks, bool SynchronizeSoundBanks);
        void STATIC_LoadBankByName(const BasicTypes::FString& BankName);
        void STATIC_LoadBankAsyncByName(const BasicTypes::FString& BankName, const BasicTypes::UScriptDelegate& BankLoadedCallback);
        void STATIC_LoadBankAsync(AkAudio::UAkAudioBank* Bank, const BasicTypes::UScriptDelegate& BankLoadedCallback);
        void STATIC_LoadBank(AkAudio::UAkAudioBank* Bank, const BasicTypes::FString& BankName, const Engine::FLatentActionInfo& LatentInfo, CoreUObject::UObject* WorldContextObject);
        bool STATIC_IsGame(CoreUObject::UObject* WorldContextObject);
        bool STATIC_IsEditor();
        void STATIC_GetSpeakerAngles(BasicTypes::TArray<float>* SpeakerAngles, float* HeightAngle, const BasicTypes::FString& DeviceShareset);
        void STATIC_GetRTPCValue(AkAudio::UAkRtpc* RTPCValue, int32_t PlayingID, AkAudio::ERTPCValueType InputValueType, float* Value, AkAudio::ERTPCValueType* OutputValueType, Engine::AActor* Actor, const BasicTypes::FName& RTPC);
        float STATIC_GetOcclusionScalingFactor();
        BasicTypes::FString STATIC_GetCurrentAudioCulture();
        BasicTypes::TArray<BasicTypes::FString> STATIC_GetAvailableAudioCultures();
        CoreUObject::UObject* STATIC_GetAkMediaAssetUserData(AkAudio::UAkMediaAsset* Instance, CoreUObject::UObject* Type);
        AkAudio::UAkComponent* STATIC_GetAkComponent(Engine::USceneComponent* AttachToComponent, bool* ComponentCreated, const BasicTypes::FName& AttachPointName, const CoreUObject::FVector& Location, Engine::EAttachLocation LocationType);
        CoreUObject::UObject* STATIC_GetAkAudioTypeUserData(AkAudio::UAkAudioType* Instance, CoreUObject::UObject* Type);
        void STATIC_ExecuteActionOnPlayingID(AkAudio::EAkActionOnEventType ActionType, int32_t PlayingID, int32_t TransitionDuration, AkAudio::EAkCurveInterpolation FadeCurve);
        void STATIC_ExecuteActionOnEvent(AkAudio::UAkAudioEvent* AkEvent, AkAudio::EAkActionOnEventType ActionType, Engine::AActor* Actor, int32_t TransitionDuration, AkAudio::EAkCurveInterpolation FadeCurve, int32_t PlayingID);
        void STATIC_ClearBanks();
        void STATIC_CancelEventCallback(const BasicTypes::UScriptDelegate& PostEventCallback);
        void STATIC_AddOutputCaptureMarker(const BasicTypes::FString& MarkerText);
        static inline CoreUObject::UClass* StaticClass()
        {
            static CoreUObject::UClass* ptr = nullptr;
            if (!ptr)
                ptr = CoreUObject::UObject::FindClass("Class /Script/AkAudio.AkGameplayStatics");
            return ptr;
        }
    };
}

#ifdef _MSC_VER
    #pragma pack(pop)
#endif
