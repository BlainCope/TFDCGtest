#pragma once

/**
 * ----------------------------------------
 * |        Generated By CheatGear        |
 * ----------------------------------------
 * | Game:    TFDCG                       |
 * | Version: 1                           |
 * | Date:    08/22/2024                  |
 * ----------------------------------------
 */

#include <cstdint>
#include <vector>
#include <string>
#include "Engine_UBlueprintFunctionLibrary.h"
#include "AugmentedReality_ENUMS.h"
#include "CoreUObject_FVector.h"
#include "CoreUObject_FRotator.h"
#include "CoreUObject_FTransform.h"
#include "BasicTypes_FName.h"
#include "CoreUObject_FIntPoint.h"
#include "AugmentedReality_FARTraceResult.h"
#include "BasicTypes_TMap.h"
#include "BasicTypes_TArray.h"
#include "CoreUObject_FVector2D.h"
#include "AugmentedReality_FARVideoFormat.h"
#include "AugmentedReality_FARCameraIntrinsics.h"
#include "AugmentedReality_FARSessionStatus.h"
#include "AugmentedReality_FARPose2D.h"
#include "BasicTypes_FString.h"
#include "CoreUObject_FLinearColor.h"

// --------------------------------------------------
// # Forwards
// --------------------------------------------------
namespace CG::Engine { class USceneComponent; };
namespace CG::AugmentedReality { class UARSessionConfig; };
namespace CG::AugmentedReality { class UARPin; };
namespace CG::AugmentedReality { class UARTrackedGeometry; };
namespace CG::AugmentedReality { class UARTexture; };
namespace CG::AugmentedReality { class UARLightEstimate; };
namespace CG::AugmentedReality { class UARTextureCameraImage; };
namespace CG::AugmentedReality { class UARTextureCameraDepth; };
namespace CG::AugmentedReality { class UARTrackedPose; };
namespace CG::AugmentedReality { class UARTrackedPoint; };
namespace CG::AugmentedReality { class UARPlaneGeometry; };
namespace CG::AugmentedReality { class UARTrackedImage; };
namespace CG::AugmentedReality { class UAREnvironmentCaptureProbe; };
namespace CG::CoreUObject { class UObject; };
namespace CG::Engine { class UTexture2D; };
namespace CG::AugmentedReality { class UARCandidateImage; };
namespace CG::CoreUObject { class UClass; };

#ifdef _MSC_VER
    #pragma pack(push, 0x01)
#endif

namespace CG::AugmentedReality
{
    /**
     * Class /Script/AugmentedReality.ARBlueprintLibrary
     * Size -> 0x0000 (FullSize[0x0028] - InheritedSize[0x0028])
     */
    class UARBlueprintLibrary : public Engine::UBlueprintFunctionLibrary
    {
    public:
        void STATIC_UnpinComponent(Engine::USceneComponent* ComponentToUnpin);
        bool STATIC_ToggleARCapture(bool bOnOff, AugmentedReality::EARCaptureType CaptureType);
        void STATIC_StopARSession();
        void STATIC_StartARSession(AugmentedReality::UARSessionConfig* SessionConfig);
        void STATIC_SetEnabledXRCamera(bool bOnOff);
        void STATIC_SetARWorldScale(float InWorldScale);
        void STATIC_SetARWorldOriginLocationAndRotation(const CoreUObject::FVector& OriginLocation, const CoreUObject::FRotator& OriginRotation, bool bIsTransformInWorldSpace, bool bMaintainUpDirection);
        void STATIC_SetAlignmentTransform(const CoreUObject::FTransform& InAlignmentTransform);
        bool STATIC_SaveARPinToLocalStore(const BasicTypes::FName& InSaveName, AugmentedReality::UARPin* InPin);
        CoreUObject::FIntPoint STATIC_ResizeXRCamera(const CoreUObject::FIntPoint& InSize);
        void STATIC_RemovePin(AugmentedReality::UARPin* PinToRemove);
        void STATIC_RemoveARPinFromLocalStore(const BasicTypes::FName& InSaveName);
        void STATIC_RemoveAllARPinsFromLocalStore();
        AugmentedReality::UARPin* STATIC_PinComponentToTraceResult(Engine::USceneComponent* ComponentToPin, const AugmentedReality::FARTraceResult& TraceResult, const BasicTypes::FName& DebugName);
        bool STATIC_PinComponentToARPin(Engine::USceneComponent* ComponentToPin, AugmentedReality::UARPin* Pin);
        AugmentedReality::UARPin* STATIC_PinComponent(Engine::USceneComponent* ComponentToPin, const CoreUObject::FTransform& PinToWorldTransform, AugmentedReality::UARTrackedGeometry* TrackedGeometry, const BasicTypes::FName& DebugName);
        void STATIC_PauseARSession();
        BasicTypes::TMap<BasicTypes::FName, AugmentedReality::UARPin*> STATIC_LoadARPinsFromLocalStore();
        BasicTypes::TArray<AugmentedReality::FARTraceResult> STATIC_LineTraceTrackedObjects3D(const CoreUObject::FVector& Start, const CoreUObject::FVector& End, bool bTestFeaturePoints, bool bTestGroundPlane, bool bTestPlaneExtents, bool bTestPlaneBoundaryPolygon);
        BasicTypes::TArray<AugmentedReality::FARTraceResult> STATIC_LineTraceTrackedObjects(const CoreUObject::FVector2D& ScreenCoord, bool bTestFeaturePoints, bool bTestGroundPlane, bool bTestPlaneExtents, bool bTestPlaneBoundaryPolygon);
        bool STATIC_IsSessionTypeSupported(AugmentedReality::EARSessionType SessionType);
        bool STATIC_IsSessionTrackingFeatureSupported(AugmentedReality::EARSessionType SessionType, AugmentedReality::EARSessionTrackingFeature SessionTrackingFeature);
        bool STATIC_IsSceneReconstructionSupported(AugmentedReality::EARSessionType SessionType, AugmentedReality::EARSceneReconstruction SceneReconstructionMethod);
        bool STATIC_IsARSupported();
        bool STATIC_IsARPinLocalStoreSupported();
        bool STATIC_IsARPinLocalStoreReady();
        AugmentedReality::EARWorldMappingState STATIC_GetWorldMappingStatus();
        AugmentedReality::EARTrackingQualityReason STATIC_GetTrackingQualityReason();
        AugmentedReality::EARTrackingQuality STATIC_GetTrackingQuality();
        BasicTypes::TArray<AugmentedReality::FARVideoFormat> STATIC_GetSupportedVideoFormats(AugmentedReality::EARSessionType SessionType);
        AugmentedReality::UARSessionConfig* STATIC_GetSessionConfig();
        BasicTypes::TArray<CoreUObject::FVector> STATIC_GetPointCloud();
        AugmentedReality::UARTexture* STATIC_GetPersonSegmentationImage();
        AugmentedReality::UARTexture* STATIC_GetPersonSegmentationDepthImage();
        bool STATIC_GetObjectClassificationAtLocation(const CoreUObject::FVector& InWorldLocation, AugmentedReality::EARObjectClassification* OutClassification, CoreUObject::FVector* OutClassificationLocation, float MaxLocationDiff);
        int32_t STATIC_GetNumberOfTrackedFacesSupported();
        AugmentedReality::UARLightEstimate* STATIC_GetCurrentLightEstimate();
        bool STATIC_GetCameraIntrinsics(AugmentedReality::FARCameraIntrinsics* OutCameraIntrinsics);
        AugmentedReality::UARTextureCameraImage* STATIC_GetCameraImage();
        AugmentedReality::UARTextureCameraDepth* STATIC_GetCameraDepth();
        float STATIC_GetARWorldScale();
        AugmentedReality::UARTexture* STATIC_GetARTexture(AugmentedReality::EARTextureType TextureType);
        AugmentedReality::FARSessionStatus STATIC_GetARSessionStatus();
        BasicTypes::TArray<AugmentedReality::UARTrackedPose*> STATIC_GetAllTrackedPoses();
        BasicTypes::TArray<AugmentedReality::UARTrackedPoint*> STATIC_GetAllTrackedPoints();
        BasicTypes::TArray<AugmentedReality::UARPlaneGeometry*> STATIC_GetAllTrackedPlanes();
        BasicTypes::TArray<AugmentedReality::UARTrackedImage*> STATIC_GetAllTrackedImages();
        BasicTypes::TArray<AugmentedReality::UAREnvironmentCaptureProbe*> STATIC_GetAllTrackedEnvironmentCaptureProbes();
        BasicTypes::TArray<AugmentedReality::FARPose2D> STATIC_GetAllTracked2DPoses();
        BasicTypes::TArray<AugmentedReality::UARPin*> STATIC_GetAllPins();
        BasicTypes::TArray<AugmentedReality::UARTrackedGeometry*> STATIC_GetAllGeometriesByClass(AugmentedReality::UARTrackedGeometry* GeometryClass);
        BasicTypes::TArray<AugmentedReality::UARTrackedGeometry*> STATIC_GetAllGeometries();
        CoreUObject::FTransform STATIC_GetAlignmentTransform();
        BasicTypes::TArray<AugmentedReality::UARTrackedPoint*> STATIC_FindTrackedPointsByName(const BasicTypes::FString& PointName);
        void STATIC_DebugDrawTrackedGeometry(AugmentedReality::UARTrackedGeometry* TrackedGeometry, CoreUObject::UObject* WorldContextObject, const CoreUObject::FLinearColor& Color, float OutlineThickness, float PersistForSeconds);
        void STATIC_DebugDrawPin(AugmentedReality::UARPin* ARPin, CoreUObject::UObject* WorldContextObject, const CoreUObject::FLinearColor& Color, float Scale, float PersistForSeconds);
        void STATIC_CalculateClosestIntersection(BasicTypes::TArray<CoreUObject::FVector> StartPoints, BasicTypes::TArray<CoreUObject::FVector> EndPoints, CoreUObject::FVector* ClosestIntersection);
        void STATIC_CalculateAlignmentTransform(const CoreUObject::FTransform& TransformInFirstCoordinateSystem, const CoreUObject::FTransform& TransformInSecondCoordinateSystem, CoreUObject::FTransform* AlignmentTransform);
        bool STATIC_AddTrackedPointWithName(const CoreUObject::FTransform& WorldTransform, const BasicTypes::FString& PointName, bool bDeletePointsWithSameName);
        AugmentedReality::UARCandidateImage* STATIC_AddRuntimeCandidateImage(AugmentedReality::UARSessionConfig* SessionConfig, Engine::UTexture2D* CandidateTexture, const BasicTypes::FString& FriendlyName, float PhysicalWidth);
        bool STATIC_AddManualEnvironmentCaptureProbe(const CoreUObject::FVector& Location, const CoreUObject::FVector& Extent);
        static inline CoreUObject::UClass* StaticClass()
        {
            static CoreUObject::UClass* ptr = nullptr;
            if (!ptr)
                ptr = CoreUObject::UObject::FindClass("Class /Script/AugmentedReality.ARBlueprintLibrary");
            return ptr;
        }
    };
}

#ifdef _MSC_VER
    #pragma pack(pop)
#endif
