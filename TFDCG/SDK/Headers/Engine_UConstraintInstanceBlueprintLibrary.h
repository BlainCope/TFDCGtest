#pragma once

/**
 * ----------------------------------------
 * |        Generated By CheatGear        |
 * ----------------------------------------
 * | Game:    TFDCG                       |
 * | Version: 1                           |
 * | Date:    08/22/2024                  |
 * ----------------------------------------
 */

#include <cstdint>
#include <vector>
#include <string>
#include "Engine_UBlueprintFunctionLibrary.h"
#include "Engine_FConstraintInstanceAccessor.h"
#include "CoreUObject_FVector.h"
#include "PhysicsCore_ENUMS.h"
#include "CoreUObject_FRotator.h"
#include "Engine_ENUMS.h"
#include "BasicTypes_FName.h"

// --------------------------------------------------
// # Forwards
// --------------------------------------------------
namespace CG::CoreUObject { class UClass; };

#ifdef _MSC_VER
    #pragma pack(push, 0x01)
#endif

namespace CG::Engine
{
    /**
     * Class /Script/Engine.ConstraintInstanceBlueprintLibrary
     * Size -> 0x0000 (FullSize[0x0028] - InheritedSize[0x0028])
     */
    class UConstraintInstanceBlueprintLibrary : public Engine::UBlueprintFunctionLibrary
    {
    public:
        void STATIC_SetProjectionParams(Engine::FConstraintInstanceAccessor* Accessor, bool bEnableProjection, float ProjectionLinearAlpha, float ProjectionAngularAlpha);
        void STATIC_SetParentDominates(Engine::FConstraintInstanceAccessor* Accessor, bool bParentDominates);
        void STATIC_SetOrientationDriveTwistAndSwing(Engine::FConstraintInstanceAccessor* Accessor, bool bEnableTwistDrive, bool bEnableSwingDrive);
        void STATIC_SetOrientationDriveSLERP(Engine::FConstraintInstanceAccessor* Accessor, bool bEnableSLERP);
        void STATIC_SetMassConditioningEnabled(Engine::FConstraintInstanceAccessor* Accessor, bool bEnableMassConditioning);
        void STATIC_SetLinearVelocityTarget(Engine::FConstraintInstanceAccessor* Accessor, const CoreUObject::FVector& InVelTarget);
        void STATIC_SetLinearVelocityDrive(Engine::FConstraintInstanceAccessor* Accessor, bool bEnableDriveX, bool bEnableDriveY, bool bEnableDriveZ);
        void STATIC_SetLinearSoftLimitParams(Engine::FConstraintInstanceAccessor* Accessor, bool bSoftLinearLimit, float LinearLimitStiffness, float LinearLimitDamping, float LinearLimitRestitution, float LinearLimitContactDistance);
        void STATIC_SetLinearPositionTarget(Engine::FConstraintInstanceAccessor* Accessor, const CoreUObject::FVector& InPosTarget);
        void STATIC_SetLinearPositionDrive(Engine::FConstraintInstanceAccessor* Accessor, bool bEnableDriveX, bool bEnableDriveY, bool bEnableDriveZ);
        void STATIC_SetLinearPlasticity(Engine::FConstraintInstanceAccessor* Accessor, bool bLinearPlasticity, float LinearPlasticityThreshold, PhysicsCore::EConstraintPlasticityType PlasticityType);
        void STATIC_SetLinearLimits(Engine::FConstraintInstanceAccessor* Accessor, PhysicsCore::ELinearConstraintMotion XMotion, PhysicsCore::ELinearConstraintMotion YMotion, PhysicsCore::ELinearConstraintMotion ZMotion, float Limit);
        void STATIC_SetLinearDriveParams(Engine::FConstraintInstanceAccessor* Accessor, float PositionStrength, float VelocityStrength, float InForceLimit);
        void STATIC_SetLinearBreakable(Engine::FConstraintInstanceAccessor* Accessor, bool bLinearBreakable, float LinearBreakThreshold);
        void STATIC_SetDisableCollision(Engine::FConstraintInstanceAccessor* Accessor, bool bDisableCollision);
        void STATIC_SetContactTransferScale(Engine::FConstraintInstanceAccessor* Accessor, float ContactTransferScale);
        void STATIC_SetAngularVelocityTarget(Engine::FConstraintInstanceAccessor* Accessor, const CoreUObject::FVector& InVelTarget);
        void STATIC_SetAngularVelocityDriveTwistAndSwing(Engine::FConstraintInstanceAccessor* Accessor, bool bEnableTwistDrive, bool bEnableSwingDrive);
        void STATIC_SetAngularVelocityDriveSLERP(Engine::FConstraintInstanceAccessor* Accessor, bool bEnableSLERP);
        void STATIC_SetAngularSoftTwistLimitParams(Engine::FConstraintInstanceAccessor* Accessor, bool bSoftTwistLimit, float TwistLimitStiffness, float TwistLimitDamping, float TwistLimitRestitution, float TwistLimitContactDistance);
        void STATIC_SetAngularSoftSwingLimitParams(Engine::FConstraintInstanceAccessor* Accessor, bool bSoftSwingLimit, float SwingLimitStiffness, float SwingLimitDamping, float SwingLimitRestitution, float SwingLimitContactDistance);
        void STATIC_SetAngularPlasticity(Engine::FConstraintInstanceAccessor* Accessor, bool bAngularPlasticity, float AngularPlasticityThreshold);
        void STATIC_SetAngularOrientationTarget(Engine::FConstraintInstanceAccessor* Accessor, const CoreUObject::FRotator& InPosTarget);
        void STATIC_SetAngularLimits(Engine::FConstraintInstanceAccessor* Accessor, PhysicsCore::EAngularConstraintMotion Swing1MotionType, float Swing1LimitAngle, PhysicsCore::EAngularConstraintMotion Swing2MotionType, float Swing2LimitAngle, PhysicsCore::EAngularConstraintMotion TwistMotionType, float TwistLimitAngle);
        void STATIC_SetAngularDriveParams(Engine::FConstraintInstanceAccessor* Accessor, float PositionStrength, float VelocityStrength, float InForceLimit);
        void STATIC_SetAngularDriveMode(Engine::FConstraintInstanceAccessor* Accessor, Engine::EAngularDriveMode DriveMode);
        void STATIC_SetAngularBreakable(Engine::FConstraintInstanceAccessor* Accessor, bool bAngularBreakable, float AngularBreakThreshold);
        void STATIC_GetProjectionParams(Engine::FConstraintInstanceAccessor* Accessor, bool* bEnableProjection, float* ProjectionLinearAlpha, float* ProjectionAngularAlpha);
        bool STATIC_GetParentDominates(Engine::FConstraintInstanceAccessor* Accessor);
        void STATIC_GetOrientationDriveTwistAndSwing(Engine::FConstraintInstanceAccessor* Accessor, bool* bOutEnableTwistDrive, bool* bOutEnableSwingDrive);
        void STATIC_GetOrientationDriveSLERP(Engine::FConstraintInstanceAccessor* Accessor, bool* bOutEnableSLERP);
        bool STATIC_GetMassConditioningEnabled(Engine::FConstraintInstanceAccessor* Accessor);
        void STATIC_GetLinearVelocityTarget(Engine::FConstraintInstanceAccessor* Accessor, CoreUObject::FVector* OutVelTarget);
        void STATIC_GetLinearVelocityDrive(Engine::FConstraintInstanceAccessor* Accessor, bool* bOutEnableDriveX, bool* bOutEnableDriveY, bool* bOutEnableDriveZ);
        void STATIC_GetLinearSoftLimitParams(Engine::FConstraintInstanceAccessor* Accessor, bool* bSoftLinearLimit, float* LinearLimitStiffness, float* LinearLimitDamping, float* LinearLimitRestitution, float* LinearLimitContactDistance);
        void STATIC_GetLinearPositionTarget(Engine::FConstraintInstanceAccessor* Accessor, CoreUObject::FVector* OutPosTarget);
        void STATIC_GetLinearPositionDrive(Engine::FConstraintInstanceAccessor* Accessor, bool* bOutEnableDriveX, bool* bOutEnableDriveY, bool* bOutEnableDriveZ);
        void STATIC_GetLinearPlasticity(Engine::FConstraintInstanceAccessor* Accessor, bool* bLinearPlasticity, float* LinearPlasticityThreshold, PhysicsCore::EConstraintPlasticityType* PlasticityType);
        void STATIC_GetLinearLimits(Engine::FConstraintInstanceAccessor* Accessor, PhysicsCore::ELinearConstraintMotion* XMotion, PhysicsCore::ELinearConstraintMotion* YMotion, PhysicsCore::ELinearConstraintMotion* ZMotion, float* Limit);
        void STATIC_GetLinearDriveParams(Engine::FConstraintInstanceAccessor* Accessor, float* OutPositionStrength, float* OutVelocityStrength, float* OutForceLimit);
        void STATIC_GetLinearBreakable(Engine::FConstraintInstanceAccessor* Accessor, bool* bLinearBreakable, float* LinearBreakThreshold);
        bool STATIC_GetDisableCollsion(Engine::FConstraintInstanceAccessor* Accessor);
        void STATIC_GetContactTransferScale(Engine::FConstraintInstanceAccessor* Accessor, float* ContactTransferScale);
        void STATIC_GetAttachedBodyNames(Engine::FConstraintInstanceAccessor* Accessor, BasicTypes::FName* ParentBody, BasicTypes::FName* ChildBody);
        void STATIC_GetAngularVelocityTarget(Engine::FConstraintInstanceAccessor* Accessor, CoreUObject::FVector* OutVelTarget);
        void STATIC_GetAngularVelocityDriveTwistAndSwing(Engine::FConstraintInstanceAccessor* Accessor, bool* bOutEnableTwistDrive, bool* bOutEnableSwingDrive);
        void STATIC_GetAngularVelocityDriveSLERP(Engine::FConstraintInstanceAccessor* Accessor, bool* bOutEnableSLERP);
        void STATIC_GetAngularSoftTwistLimitParams(Engine::FConstraintInstanceAccessor* Accessor, bool* bSoftTwistLimit, float* TwistLimitStiffness, float* TwistLimitDamping, float* TwistLimitRestitution, float* TwistLimitContactDistance);
        void STATIC_GetAngularSoftSwingLimitParams(Engine::FConstraintInstanceAccessor* Accessor, bool* bSoftSwingLimit, float* SwingLimitStiffness, float* SwingLimitDamping, float* SwingLimitRestitution, float* SwingLimitContactDistance);
        void STATIC_GetAngularPlasticity(Engine::FConstraintInstanceAccessor* Accessor, bool* bAngularPlasticity, float* AngularPlasticityThreshold);
        void STATIC_GetAngularOrientationTarget(Engine::FConstraintInstanceAccessor* Accessor, CoreUObject::FRotator* OutPosTarget);
        void STATIC_GetAngularLimits(Engine::FConstraintInstanceAccessor* Accessor, PhysicsCore::EAngularConstraintMotion* Swing1MotionType, float* Swing1LimitAngle, PhysicsCore::EAngularConstraintMotion* Swing2MotionType, float* Swing2LimitAngle, PhysicsCore::EAngularConstraintMotion* TwistMotionType, float* TwistLimitAngle);
        void STATIC_GetAngularDriveParams(Engine::FConstraintInstanceAccessor* Accessor, float* OutPositionStrength, float* OutVelocityStrength, float* OutForceLimit);
        void STATIC_GetAngularDriveMode(Engine::FConstraintInstanceAccessor* Accessor, Engine::EAngularDriveMode* OutDriveMode);
        void STATIC_GetAngularBreakable(Engine::FConstraintInstanceAccessor* Accessor, bool* bAngularBreakable, float* AngularBreakThreshold);
        void STATIC_CopyParams(Engine::FConstraintInstanceAccessor* Accessor, Engine::FConstraintInstanceAccessor* SourceAccessor, bool bKeepPosition, bool bKeepRotation);
        static inline CoreUObject::UClass* StaticClass()
        {
            static CoreUObject::UClass* ptr = nullptr;
            if (!ptr)
                ptr = CoreUObject::UObject::FindClass("Class /Script/Engine.ConstraintInstanceBlueprintLibrary");
            return ptr;
        }
    };
}

#ifdef _MSC_VER
    #pragma pack(pop)
#endif
