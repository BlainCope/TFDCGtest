#pragma once

/**
 * ----------------------------------------
 * |        Generated By CheatGear        |
 * ----------------------------------------
 * | Game:    TFDCG                       |
 * | Version: 1                           |
 * | Date:    08/22/2024                  |
 * ----------------------------------------
 */

#include <cstdint>
#include <vector>
#include <string>
#include "Engine_UBlueprintFunctionLibrary.h"
#include "BasicTypes_TArray.h"
#include "CoreUObject_FVector.h"
#include "Engine_ENUMS.h"
#include "Engine_FHitResult.h"
#include "CoreUObject_FLinearColor.h"
#include "CoreUObject_FFloatRange.h"
#include "M1_ENUMS.h"
#include "M1Data_FM1TemplateId.h"
#include "M1Data_ENUMS.h"
#include "BasicTypes_FString.h"
#include "CoreUObject_FVector2D.h"

// --------------------------------------------------
// # Forwards
// --------------------------------------------------
namespace CG::CoreUObject { class UObject; };
namespace CG::Engine { class UCameraShakeBase; };
namespace CG::Engine { class APlayerController; };
namespace CG::Engine { class AActor; };
namespace CG::M1 { class AM1Player; };
namespace CG::Engine { class ASkeletalMeshActor; };
namespace CG::CoreUObject { class UClass; };

#ifdef _MSC_VER
    #pragma pack(push, 0x01)
#endif

namespace CG::M1
{
    /**
     * Class /Script/M1.M1GameplayUtil
     * Size -> 0x0000 (FullSize[0x0028] - InheritedSize[0x0028])
     */
    class UM1GameplayUtil : public Engine::UBlueprintFunctionLibrary
    {
    public:
        void STATIC_StartCameraShake(CoreUObject::UObject* WorldContextObject, Engine::UCameraShakeBase* CameraShake);
        void STATIC_SortActorsByDistanceToScreenCenter(Engine::APlayerController* Player, BasicTypes::TArray<Engine::AActor*>* InOutActors);
        void STATIC_PropagateMissionDerivativeToChild(Engine::AActor* InParent, Engine::AActor* InChild);
        CoreUObject::FVector STATIC_MakeHitFXLocationWithPlanarOffset(const CoreUObject::FVector& FireLocation, const CoreUObject::FVector& HitLocation, float OffsetMax);
        bool STATIC_LineTraceFromViewport(Engine::AActor* Owner, const CoreUObject::FVector& BaseLoc, float Range, Engine::ECollisionChannel TraceChannel, bool bCheckValidTarget, bool bTraceComplex, BasicTypes::TArray<Engine::FHitResult>* OutHits);
        bool STATIC_IsTargetOnPlayerScreen(CoreUObject::UObject* WorldContextObject, const CoreUObject::FVector& TargetLocation);
        bool STATIC_IsTargetInSightOnXYPlane(CoreUObject::UObject* WorldContextObject, const CoreUObject::FVector& InViewerLocation, const CoreUObject::FVector& InViewerDirection, const CoreUObject::FVector& InTargetLocation, float InHalfFovDegrees, float InRange, bool InDebugDraw, const CoreUObject::FLinearColor& InDrawingColor);
        bool STATIC_IsTargetInScreen(CoreUObject::UObject* WorldContextObject, Engine::AActor* InTarget, bool InbDebugDraw);
        bool STATIC_IsFloatRangeContains(const CoreUObject::FFloatRange& Range, float Target);
        M1Data::FM1TemplateId STATIC_GetTemplateIdByPlayableCharacter(M1::EM1PlayableCharacter InCharacter);
        int32_t STATIC_GetSpareRoundsCapacity(M1::AM1Player* LocalOrAuthPlayer, M1Data::EM1RoundsType RoundsType);
        int32_t STATIC_GetCurrentSpareRounds(M1::AM1Player* LocalOrAuthPlayer, M1Data::EM1RoundsType RoundsType);
        M1Data::EM1MapType STATIC_GetCurrentMapType(CoreUObject::UObject* WorldContextObject);
        float STATIC_GetCrosshairScale(CoreUObject::UObject* WorldContextObject);
        BasicTypes::FString STATIC_GetCharacterStringIdByPlayableCharacter(M1::EM1PlayableCharacter InCharacter);
        void STATIC_ExecuteConsoleCommands(CoreUObject::UObject* WorldContextObject, BasicTypes::TArray<BasicTypes::FString> Commands, Engine::APlayerController* Player);
        bool STATIC_ConvertWorldToWidgetPosition(Engine::APlayerController* Player, const CoreUObject::FVector& WorldPosition, bool bPlayerViewportRelative, CoreUObject::FVector2D* OutScreenPosition, const CoreUObject::FVector2D& OptionalClampRect);
        bool STATIC_CalcActorWidgetPosition(Engine::APlayerController* Player, Engine::AActor* Actor, CoreUObject::FVector2D* OutScreenPosition, const CoreUObject::FVector2D& OptionalClampRect);
        void STATIC_Auth_GiveSpareRounds(M1::AM1Player* AuthPlayer, M1Data::EM1RoundsType RoundsType, int32_t GiveAmount, bool bAllowExceed);
        bool STATIC_Auth_FollowActor(Engine::AActor* Actor, Engine::AActor* FollowActor);
        void STATIC_ApplyPlayableCharacterToSequenceCharacter(CoreUObject::UObject* WorldContextObject, Engine::ASkeletalMeshActor* InMeshActor, M1Data::EM1CharacterGender InType);
        static inline CoreUObject::UClass* StaticClass()
        {
            static CoreUObject::UClass* ptr = nullptr;
            if (!ptr)
                ptr = CoreUObject::UObject::FindClass("Class /Script/M1.M1GameplayUtil");
            return ptr;
        }
    };
}

#ifdef _MSC_VER
    #pragma pack(pop)
#endif
