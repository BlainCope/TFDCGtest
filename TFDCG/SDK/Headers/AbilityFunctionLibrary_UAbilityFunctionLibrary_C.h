#pragma once

/**
 * ----------------------------------------
 * |        Generated By CheatGear        |
 * ----------------------------------------
 * | Game:    TFDCG                       |
 * | Version: 1                           |
 * | Date:    08/22/2024                  |
 * ----------------------------------------
 */

#include <cstdint>
#include <vector>
#include <string>
#include "Engine_UBlueprintFunctionLibrary.h"
#include "BasicTypes_FName.h"
#include "CoreUObject_FVector.h"
#include "CoreUObject_FTransform.h"
#include "BasicTypes_TArray.h"
#include "M1_FM1FXScalarParam.h"
#include "M1_FM1AbilityOperationParam.h"
#include "M1Data_FM1AbilityParamData.h"
#include "M1Data_ENUMS.h"
#include "GameplayTags_FGameplayTagContainer.h"
#include "BasicTypes_TScriptInterface.h"
#include "M1_IM1AbilityBase.h"
#include "M1Data_FM1ScaledInteger.h"

// --------------------------------------------------
// # Forwards
// --------------------------------------------------
namespace CG::Engine { class AActor; };
namespace CG::CoreUObject { class UObject; };
namespace CG::Engine { class UAnimSequence; };
namespace CG::M1 { class AM1Monster; };
namespace CG::M1 { class UM1Ability; };
namespace CG::Engine { class UPrimitiveComponent; };
namespace CG::M1AOECollisionManager { class UM1AOECollisionManager_C; };
namespace CG::CoreUObject { class UClass; };

#ifdef _MSC_VER
    #pragma pack(push, 0x01)
#endif

namespace CG::AbilityFunctionLibrary
{
    /**
     * BlueprintGeneratedClass /Game/Blueprints/Gameplay/AbilityFunctionLibrary.AbilityFunctionLibrary_C
     * Size -> 0x0000 (FullSize[0x0028] - InheritedSize[0x0028])
     */
    class UAbilityFunctionLibrary_C : public Engine::UBlueprintFunctionLibrary
    {
    public:
        void STATIC_FindRandomTeleportLocationFromSpawnTransformMaker(Engine::AActor* WorldContext, const BasicTypes::FName& InMakerName, CoreUObject::UObject* __WorldContext, CoreUObject::FVector* RandomLocation);
        void STATIC_TryLoadAnimSequence(const BasicTypes::FName& AssetPath, CoreUObject::UObject* __WorldContext, Engine::UAnimSequence** AnimSequence);
        void STATIC_SummonMonster(M1::AM1Monster* Master, const BasicTypes::FName& MonsterRowName, int32_t Level, const CoreUObject::FTransform& TargetTransform, CoreUObject::UObject* __WorldContext, M1::AM1Monster** SpawnedMonster);
        void STATIC_MakeDecalParams(double Duration, double Size, double Height, bool UseScaledSize, CoreUObject::UObject* __WorldContext, BasicTypes::TArray<M1::FM1FXScalarParam>* ReturnParams);
        void STATIC_MakeMaxHpOperationParam(double MaxHPRatio, CoreUObject::UObject* __WorldContext, M1::FM1AbilityOperationParam* Result);
        void STATIC_MakeMaxHpAbilityParam(double MaxHPRatio, CoreUObject::UObject* __WorldContext, M1Data::FM1AbilityParamData* Result);
        void STATIC_GetAIHomeLocation(M1::UM1Ability* Ability, CoreUObject::UObject* __WorldContext, CoreUObject::FVector* HomeLocation);
        M1AOECollisionManager::UM1AOECollisionManager_C* STATIC_CreateAOEActorManager(CoreUObject::UObject* Outer, Engine::UPrimitiveComponent* PrimitiveComp, M1Data::EM1RelationsCheckType RelationsType, const GameplayTags::FGameplayTagContainer& SEForwardingContextTags, const GameplayTags::FGameplayTagContainer& SEInvokeTags, float Period, const GameplayTags::FGameplayTagContainer& PeriodOpTags, const BasicTypes::FName& PeriodHitFXName, bool bStartOverlap, bool bNeedEndSE, CoreUObject::UObject* __WorldContext);
        void STATIC_InvokeDotDamageStatusEffect(const BasicTypes::TScriptInterface<M1::IM1AbilityBase>& InAbility, const GameplayTags::FGameplayTagContainer& ForwardingOperationTags, const GameplayTags::FGameplayTagContainer& InTags, const M1Data::FM1ScaledInteger& Damage, Engine::AActor* TargetActor, CoreUObject::UObject* __WorldContext);
        void STATIC_CalcSummonsFireStartEndLocation(Engine::AActor* InOwner, const CoreUObject::FVector& InTargetLoc, const CoreUObject::FVector& InFireSocketLoc, const CoreUObject::FVector& InAxisSocketLoc, int32_t InSpreadSize, CoreUObject::UObject* __WorldContext, CoreUObject::FVector* FireLoc, CoreUObject::FVector* EndLoc);
        CoreUObject::FTransform STATIC_GetTransformForAbilityActor(M1::UM1Ability* InAbility, const BasicTypes::FName& InSocketName, CoreUObject::UObject* __WorldContext);
        static inline CoreUObject::UClass* StaticClass()
        {
            static CoreUObject::UClass* ptr = nullptr;
            if (!ptr)
                ptr = CoreUObject::UObject::FindClass("BlueprintGeneratedClass /Game/Blueprints/Gameplay/AbilityFunctionLibrary.AbilityFunctionLibrary_C");
            return ptr;
        }
    };
}

#ifdef _MSC_VER
    #pragma pack(pop)
#endif
