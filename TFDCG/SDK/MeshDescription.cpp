/**
 * ----------------------------------------
 * |        Generated By CheatGear        |
 * ----------------------------------------
 * | Game:    TFDCG                       |
 * | Version: 1                           |
 * | Date:    08/22/2024                  |
 * ----------------------------------------
 */

#include "pch.h"
#include <cstdint>
#include <vector>
#include <string>
#include <locale>
#include <unordered_set>
#include "Headers/Global_DEFINES.h"
#include "Headers/BasicTypes.h"
#include "Headers/CoreUObject_UFunction.h"
#include "Headers/MeshDescription_ENUMS.h"
#include "Headers/MeshDescription_PARAMS.h"
#include "Headers/MeshDescription_UMeshDescriptionBase.h"
#include "Headers/MeshDescription_UMeshDescriptionBaseBulkData.h"

#ifdef _MSC_VER
    #pragma pack(push, 0x01)
#endif

namespace CG::MeshDescription
{
    // --------------------------------------------------
    // # Structs functions
    // --------------------------------------------------
    /**
     * Function:
     *         RVA    -> 0x04FAEB50
     *         Name   -> Function /Script/MeshDescription.MeshDescriptionBase.SetVertexPosition
     *         Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
     * Parameters:
     *         MeshDescription::FVertexID                         VertexID                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         CoreUObject::FVector                               Position                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         void                                               ReturnValue
     */
    void UMeshDescriptionBase::SetVertexPosition(const MeshDescription::FVertexID& VertexID, const CoreUObject::FVector& Position)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/MeshDescription.MeshDescriptionBase.SetVertexPosition");
        
        UMeshDescriptionBase_SetVertexPosition_Params params {};
        params.VertexID = VertexID;
        params.Position = Position;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
    }

    /**
     * Function:
     *         RVA    -> 0x04FAA3A0
     *         Name   -> Function /Script/MeshDescription.MeshDescriptionBase.SetPolygonVertexInstances
     *         Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
     * Parameters:
     *         MeshDescription::FPolygonID                        PolygonID                                                  (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         BasicTypes::TArray<MeshDescription::FVertexInstanceID> VertexInstanceIDs                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
     *         void                                               ReturnValue
     */
    void UMeshDescriptionBase::SetPolygonVertexInstances(const MeshDescription::FPolygonID& PolygonID, BasicTypes::TArray<MeshDescription::FVertexInstanceID> VertexInstanceIDs)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/MeshDescription.MeshDescriptionBase.SetPolygonVertexInstances");
        
        UMeshDescriptionBase_SetPolygonVertexInstances_Params params {};
        params.PolygonID = PolygonID;
        params.VertexInstanceIDs = VertexInstanceIDs;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
    }

    /**
     * Function:
     *         RVA    -> 0x04FAA170
     *         Name   -> Function /Script/MeshDescription.MeshDescriptionBase.SetPolygonPolygonGroup
     *         Flags  -> (Final, Native, Public, BlueprintCallable)
     * Parameters:
     *         MeshDescription::FPolygonID                        PolygonID                                                  (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         MeshDescription::FPolygonGroupID                   PolygonGroupID                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         void                                               ReturnValue
     */
    void UMeshDescriptionBase::SetPolygonPolygonGroup(const MeshDescription::FPolygonID& PolygonID, const MeshDescription::FPolygonGroupID& PolygonGroupID)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/MeshDescription.MeshDescriptionBase.SetPolygonPolygonGroup");
        
        UMeshDescriptionBase_SetPolygonPolygonGroup_Params params {};
        params.PolygonID = PolygonID;
        params.PolygonGroupID = PolygonGroupID;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
    }

    /**
     * Function:
     *         RVA    -> 0x04FAA030
     *         Name   -> Function /Script/MeshDescription.MeshDescriptionBase.ReversePolygonFacing
     *         Flags  -> (Final, Native, Public, BlueprintCallable)
     * Parameters:
     *         MeshDescription::FPolygonID                        PolygonID                                                  (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         void                                               ReturnValue
     */
    void UMeshDescriptionBase::ReversePolygonFacing(const MeshDescription::FPolygonID& PolygonID)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/MeshDescription.MeshDescriptionBase.ReversePolygonFacing");
        
        UMeshDescriptionBase_ReversePolygonFacing_Params params {};
        params.PolygonID = PolygonID;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
    }

    /**
     * Function:
     *         RVA    -> 0x04FB3A00
     *         Name   -> Function /Script/MeshDescription.MeshDescriptionBase.ReserveNewVertices
     *         Flags  -> (Final, Native, Public, BlueprintCallable)
     * Parameters:
     *         int32_t                                            NumberOfNewVertices                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         void                                               ReturnValue
     */
    void UMeshDescriptionBase::ReserveNewVertices(int32_t NumberOfNewVertices)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/MeshDescription.MeshDescriptionBase.ReserveNewVertices");
        
        UMeshDescriptionBase_ReserveNewVertices_Params params {};
        params.NumberOfNewVertices = NumberOfNewVertices;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
    }

    /**
     * Function:
     *         RVA    -> 0x04FB2D80
     *         Name   -> Function /Script/MeshDescription.MeshDescriptionBase.ReserveNewVertexInstances
     *         Flags  -> (Final, Native, Public, BlueprintCallable)
     * Parameters:
     *         int32_t                                            NumberOfNewVertexInstances                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         void                                               ReturnValue
     */
    void UMeshDescriptionBase::ReserveNewVertexInstances(int32_t NumberOfNewVertexInstances)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/MeshDescription.MeshDescriptionBase.ReserveNewVertexInstances");
        
        UMeshDescriptionBase_ReserveNewVertexInstances_Params params {};
        params.NumberOfNewVertexInstances = NumberOfNewVertexInstances;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
    }

    /**
     * Function:
     *         RVA    -> 0x04FB2300
     *         Name   -> Function /Script/MeshDescription.MeshDescriptionBase.ReserveNewTriangles
     *         Flags  -> (Final, Native, Public, BlueprintCallable)
     * Parameters:
     *         int32_t                                            NumberOfNewTriangles                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         void                                               ReturnValue
     */
    void UMeshDescriptionBase::ReserveNewTriangles(int32_t NumberOfNewTriangles)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/MeshDescription.MeshDescriptionBase.ReserveNewTriangles");
        
        UMeshDescriptionBase_ReserveNewTriangles_Params params {};
        params.NumberOfNewTriangles = NumberOfNewTriangles;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
    }

    /**
     * Function:
     *         RVA    -> 0x04FB1600
     *         Name   -> Function /Script/MeshDescription.MeshDescriptionBase.ReserveNewPolygons
     *         Flags  -> (Final, Native, Public, BlueprintCallable)
     * Parameters:
     *         int32_t                                            NumberOfNewPolygons                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         void                                               ReturnValue
     */
    void UMeshDescriptionBase::ReserveNewPolygons(int32_t NumberOfNewPolygons)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/MeshDescription.MeshDescriptionBase.ReserveNewPolygons");
        
        UMeshDescriptionBase_ReserveNewPolygons_Params params {};
        params.NumberOfNewPolygons = NumberOfNewPolygons;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
    }

    /**
     * Function:
     *         RVA    -> 0x04FB0900
     *         Name   -> Function /Script/MeshDescription.MeshDescriptionBase.ReserveNewPolygonGroups
     *         Flags  -> (Final, Native, Public, BlueprintCallable)
     * Parameters:
     *         int32_t                                            NumberOfNewPolygonGroups                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         void                                               ReturnValue
     */
    void UMeshDescriptionBase::ReserveNewPolygonGroups(int32_t NumberOfNewPolygonGroups)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/MeshDescription.MeshDescriptionBase.ReserveNewPolygonGroups");
        
        UMeshDescriptionBase_ReserveNewPolygonGroups_Params params {};
        params.NumberOfNewPolygonGroups = NumberOfNewPolygonGroups;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
    }

    /**
     * Function:
     *         RVA    -> 0x04FB2D80
     *         Name   -> Function /Script/MeshDescription.MeshDescriptionBase.ReserveNewEdges
     *         Flags  -> (Final, Native, Public, BlueprintCallable)
     * Parameters:
     *         int32_t                                            NumberOfNewEdges                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         void                                               ReturnValue
     */
    void UMeshDescriptionBase::ReserveNewEdges(int32_t NumberOfNewEdges)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/MeshDescription.MeshDescriptionBase.ReserveNewEdges");
        
        UMeshDescriptionBase_ReserveNewEdges_Params params {};
        params.NumberOfNewEdges = NumberOfNewEdges;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
    }

    /**
     * Function:
     *         RVA    -> 0x04FB35E0
     *         Name   -> Function /Script/MeshDescription.MeshDescriptionBase.IsVertexValid
     *         Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
     * Parameters:
     *         MeshDescription::FVertexID                         VertexID                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     */
    bool UMeshDescriptionBase::IsVertexValid(const MeshDescription::FVertexID& VertexID)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/MeshDescription.MeshDescriptionBase.IsVertexValid");
        
        UMeshDescriptionBase_IsVertexValid_Params params {};
        params.VertexID = VertexID;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        return params.ReturnValue;
    }

    /**
     * Function:
     *         RVA    -> 0x04FB0320
     *         Name   -> Function /Script/MeshDescription.MeshDescriptionBase.IsVertexOrphaned
     *         Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
     * Parameters:
     *         MeshDescription::FVertexID                         VertexID                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     */
    bool UMeshDescriptionBase::IsVertexOrphaned(const MeshDescription::FVertexID& VertexID)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/MeshDescription.MeshDescriptionBase.IsVertexOrphaned");
        
        UMeshDescriptionBase_IsVertexOrphaned_Params params {};
        params.VertexID = VertexID;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        return params.ReturnValue;
    }

    /**
     * Function:
     *         RVA    -> 0x04FB2EC0
     *         Name   -> Function /Script/MeshDescription.MeshDescriptionBase.IsVertexInstanceValid
     *         Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
     * Parameters:
     *         MeshDescription::FVertexInstanceID                 VertexInstanceID                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     */
    bool UMeshDescriptionBase::IsVertexInstanceValid(const MeshDescription::FVertexInstanceID& VertexInstanceID)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/MeshDescription.MeshDescriptionBase.IsVertexInstanceValid");
        
        UMeshDescriptionBase_IsVertexInstanceValid_Params params {};
        params.VertexInstanceID = VertexInstanceID;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        return params.ReturnValue;
    }

    /**
     * Function:
     *         RVA    -> 0x04FB1740
     *         Name   -> Function /Script/MeshDescription.MeshDescriptionBase.IsTriangleValid
     *         Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
     * Parameters:
     *         MeshDescription::FTriangleID                       TriangleID                                                 (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     */
    bool UMeshDescriptionBase::IsTriangleValid(const MeshDescription::FTriangleID& TriangleID)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/MeshDescription.MeshDescriptionBase.IsTriangleValid");
        
        UMeshDescriptionBase_IsTriangleValid_Params params {};
        params.TriangleID = TriangleID;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        return params.ReturnValue;
    }

    /**
     * Function:
     *         RVA    -> 0x04FACB80
     *         Name   -> Function /Script/MeshDescription.MeshDescriptionBase.IsTrianglePartOfNgon
     *         Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
     * Parameters:
     *         MeshDescription::FTriangleID                       TriangleID                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     */
    bool UMeshDescriptionBase::IsTrianglePartOfNgon(const MeshDescription::FTriangleID& TriangleID)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/MeshDescription.MeshDescriptionBase.IsTrianglePartOfNgon");
        
        UMeshDescriptionBase_IsTrianglePartOfNgon_Params params {};
        params.TriangleID = TriangleID;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        return params.ReturnValue;
    }

    /**
     * Function:
     *         RVA    -> 0x04FB0A40
     *         Name   -> Function /Script/MeshDescription.MeshDescriptionBase.IsPolygonValid
     *         Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
     * Parameters:
     *         MeshDescription::FPolygonID                        PolygonID                                                  (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     */
    bool UMeshDescriptionBase::IsPolygonValid(const MeshDescription::FPolygonID& PolygonID)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/MeshDescription.MeshDescriptionBase.IsPolygonValid");
        
        UMeshDescriptionBase_IsPolygonValid_Params params {};
        params.PolygonID = PolygonID;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        return params.ReturnValue;
    }

    /**
     * Function:
     *         RVA    -> 0x04FB04B0
     *         Name   -> Function /Script/MeshDescription.MeshDescriptionBase.IsPolygonGroupValid
     *         Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
     * Parameters:
     *         MeshDescription::FPolygonGroupID                   PolygonGroupID                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     */
    bool UMeshDescriptionBase::IsPolygonGroupValid(const MeshDescription::FPolygonGroupID& PolygonGroupID)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/MeshDescription.MeshDescriptionBase.IsPolygonGroupValid");
        
        UMeshDescriptionBase_IsPolygonGroupValid_Params params {};
        params.PolygonGroupID = PolygonGroupID;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        return params.ReturnValue;
    }

    /**
     * Function:
     *         RVA    -> 0x04FB3B00
     *         Name   -> Function /Script/MeshDescription.MeshDescriptionBase.IsEmpty
     *         Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
     * Parameters:
     *         bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     */
    bool UMeshDescriptionBase::IsEmpty()
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/MeshDescription.MeshDescriptionBase.IsEmpty");
        
        UMeshDescriptionBase_IsEmpty_Params params {};
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        return params.ReturnValue;
    }

    /**
     * Function:
     *         RVA    -> 0x04FB2440
     *         Name   -> Function /Script/MeshDescription.MeshDescriptionBase.IsEdgeValid
     *         Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
     * Parameters:
     *         MeshDescription::FEdgeID                           EdgeID                                                     (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     */
    bool UMeshDescriptionBase::IsEdgeValid(const MeshDescription::FEdgeID& EdgeID)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/MeshDescription.MeshDescriptionBase.IsEdgeValid");
        
        UMeshDescriptionBase_IsEdgeValid_Params params {};
        params.EdgeID = EdgeID;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        return params.ReturnValue;
    }

    /**
     * Function:
     *         RVA    -> 0x04FADC80
     *         Name   -> Function /Script/MeshDescription.MeshDescriptionBase.IsEdgeInternalToPolygon
     *         Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
     * Parameters:
     *         MeshDescription::FEdgeID                           EdgeID                                                     (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         MeshDescription::FPolygonID                        PolygonID                                                  (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     */
    bool UMeshDescriptionBase::IsEdgeInternalToPolygon(const MeshDescription::FEdgeID& EdgeID, const MeshDescription::FPolygonID& PolygonID)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/MeshDescription.MeshDescriptionBase.IsEdgeInternalToPolygon");
        
        UMeshDescriptionBase_IsEdgeInternalToPolygon_Params params {};
        params.EdgeID = EdgeID;
        params.PolygonID = PolygonID;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        return params.ReturnValue;
    }

    /**
     * Function:
     *         RVA    -> 0x04FADEC0
     *         Name   -> Function /Script/MeshDescription.MeshDescriptionBase.IsEdgeInternal
     *         Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
     * Parameters:
     *         MeshDescription::FEdgeID                           EdgeID                                                     (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     */
    bool UMeshDescriptionBase::IsEdgeInternal(const MeshDescription::FEdgeID& EdgeID)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/MeshDescription.MeshDescriptionBase.IsEdgeInternal");
        
        UMeshDescriptionBase_IsEdgeInternal_Params params {};
        params.EdgeID = EdgeID;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        return params.ReturnValue;
    }

    /**
     * Function:
     *         RVA    -> 0x04FAFA50
     *         Name   -> Function /Script/MeshDescription.MeshDescriptionBase.GetVertexVertexInstances
     *         Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
     * Parameters:
     *         MeshDescription::FVertexID                         VertexID                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         BasicTypes::TArray<MeshDescription::FVertexInstanceID> OutVertexInstanceIDs                                       (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
     *         void                                               ReturnValue
     */
    void UMeshDescriptionBase::GetVertexVertexInstances(const MeshDescription::FVertexID& VertexID, BasicTypes::TArray<MeshDescription::FVertexInstanceID>* OutVertexInstanceIDs)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/MeshDescription.MeshDescriptionBase.GetVertexVertexInstances");
        
        UMeshDescriptionBase_GetVertexVertexInstances_Params params {};
        params.VertexID = VertexID;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        if (OutVertexInstanceIDs != nullptr)
            *OutVertexInstanceIDs = params.OutVertexInstanceIDs;
    }

    /**
     * Function:
     *         RVA    -> 0x04FAEDF0
     *         Name   -> Function /Script/MeshDescription.MeshDescriptionBase.GetVertexPosition
     *         Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
     * Parameters:
     *         MeshDescription::FVertexID                         VertexID                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         CoreUObject::FVector                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     */
    CoreUObject::FVector UMeshDescriptionBase::GetVertexPosition(const MeshDescription::FVertexID& VertexID)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/MeshDescription.MeshDescriptionBase.GetVertexPosition");
        
        UMeshDescriptionBase_GetVertexPosition_Params params {};
        params.VertexID = VertexID;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        return params.ReturnValue;
    }

    /**
     * Function:
     *         RVA    -> 0x04FB00F0
     *         Name   -> Function /Script/MeshDescription.MeshDescriptionBase.GetVertexPairEdge
     *         Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
     * Parameters:
     *         MeshDescription::FVertexID                         VertexID0                                                  (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         MeshDescription::FVertexID                         VertexID1                                                  (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         MeshDescription::FEdgeID                           ReturnValue                                                (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     */
    MeshDescription::FEdgeID UMeshDescriptionBase::GetVertexPairEdge(const MeshDescription::FVertexID& VertexID0, const MeshDescription::FVertexID& VertexID1)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/MeshDescription.MeshDescriptionBase.GetVertexPairEdge");
        
        UMeshDescriptionBase_GetVertexPairEdge_Params params {};
        params.VertexID0 = VertexID0;
        params.VertexID1 = VertexID1;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        return params.ReturnValue;
    }

    /**
     * Function:
     *         RVA    -> 0x04FAE9F0
     *         Name   -> Function /Script/MeshDescription.MeshDescriptionBase.GetVertexInstanceVertex
     *         Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
     * Parameters:
     *         MeshDescription::FVertexInstanceID                 VertexInstanceID                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         MeshDescription::FVertexID                         ReturnValue                                                (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     */
    MeshDescription::FVertexID UMeshDescriptionBase::GetVertexInstanceVertex(const MeshDescription::FVertexInstanceID& VertexInstanceID)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/MeshDescription.MeshDescriptionBase.GetVertexInstanceVertex");
        
        UMeshDescriptionBase_GetVertexInstanceVertex_Params params {};
        params.VertexInstanceID = VertexInstanceID;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        return params.ReturnValue;
    }

    /**
     * Function:
     *         RVA    -> 0x04FAE7C0
     *         Name   -> Function /Script/MeshDescription.MeshDescriptionBase.GetVertexInstancePairEdge
     *         Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
     * Parameters:
     *         MeshDescription::FVertexInstanceID                 VertexInstanceID0                                          (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         MeshDescription::FVertexInstanceID                 VertexInstanceID1                                          (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         MeshDescription::FEdgeID                           ReturnValue                                                (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     */
    MeshDescription::FEdgeID UMeshDescriptionBase::GetVertexInstancePairEdge(const MeshDescription::FVertexInstanceID& VertexInstanceID0, const MeshDescription::FVertexInstanceID& VertexInstanceID1)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/MeshDescription.MeshDescriptionBase.GetVertexInstancePairEdge");
        
        UMeshDescriptionBase_GetVertexInstancePairEdge_Params params {};
        params.VertexInstanceID0 = VertexInstanceID0;
        params.VertexInstanceID1 = VertexInstanceID1;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        return params.ReturnValue;
    }

    /**
     * Function:
     *         RVA    -> 0x04FABCA0
     *         Name   -> Function /Script/MeshDescription.MeshDescriptionBase.GetVertexInstanceForTriangleVertex
     *         Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
     * Parameters:
     *         MeshDescription::FTriangleID                       TriangleID                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         MeshDescription::FVertexID                         VertexID                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         MeshDescription::FVertexInstanceID                 ReturnValue                                                (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     */
    MeshDescription::FVertexInstanceID UMeshDescriptionBase::GetVertexInstanceForTriangleVertex(const MeshDescription::FTriangleID& TriangleID, const MeshDescription::FVertexID& VertexID)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/MeshDescription.MeshDescriptionBase.GetVertexInstanceForTriangleVertex");
        
        UMeshDescriptionBase_GetVertexInstanceForTriangleVertex_Params params {};
        params.TriangleID = TriangleID;
        params.VertexID = VertexID;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        return params.ReturnValue;
    }

    /**
     * Function:
     *         RVA    -> 0x04FAA630
     *         Name   -> Function /Script/MeshDescription.MeshDescriptionBase.GetVertexInstanceForPolygonVertex
     *         Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
     * Parameters:
     *         MeshDescription::FPolygonID                        PolygonID                                                  (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         MeshDescription::FVertexID                         VertexID                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         MeshDescription::FVertexInstanceID                 ReturnValue                                                (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     */
    MeshDescription::FVertexInstanceID UMeshDescriptionBase::GetVertexInstanceForPolygonVertex(const MeshDescription::FPolygonID& PolygonID, const MeshDescription::FVertexID& VertexID)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/MeshDescription.MeshDescriptionBase.GetVertexInstanceForPolygonVertex");
        
        UMeshDescriptionBase_GetVertexInstanceForPolygonVertex_Params params {};
        params.PolygonID = PolygonID;
        params.VertexID = VertexID;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        return params.ReturnValue;
    }

    /**
     * Function:
     *         RVA    -> 0x04FB2E80
     *         Name   -> Function /Script/MeshDescription.MeshDescriptionBase.GetVertexInstanceCount
     *         Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
     * Parameters:
     *         int32_t                                            ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     */
    int32_t UMeshDescriptionBase::GetVertexInstanceCount()
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/MeshDescription.MeshDescriptionBase.GetVertexInstanceCount");
        
        UMeshDescriptionBase_GetVertexInstanceCount_Params params {};
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        return params.ReturnValue;
    }

    /**
     * Function:
     *         RVA    -> 0x04FAE520
     *         Name   -> Function /Script/MeshDescription.MeshDescriptionBase.GetVertexInstanceConnectedTriangles
     *         Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
     * Parameters:
     *         MeshDescription::FVertexInstanceID                 VertexInstanceID                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         BasicTypes::TArray<MeshDescription::FTriangleID>   OutConnectedTriangleIDs                                    (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
     *         void                                               ReturnValue
     */
    void UMeshDescriptionBase::GetVertexInstanceConnectedTriangles(const MeshDescription::FVertexInstanceID& VertexInstanceID, BasicTypes::TArray<MeshDescription::FTriangleID>* OutConnectedTriangleIDs)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/MeshDescription.MeshDescriptionBase.GetVertexInstanceConnectedTriangles");
        
        UMeshDescriptionBase_GetVertexInstanceConnectedTriangles_Params params {};
        params.VertexInstanceID = VertexInstanceID;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        if (OutConnectedTriangleIDs != nullptr)
            *OutConnectedTriangleIDs = params.OutConnectedTriangleIDs;
    }

    /**
     * Function:
     *         RVA    -> 0x04FAE1A0
     *         Name   -> Function /Script/MeshDescription.MeshDescriptionBase.GetVertexInstanceConnectedPolygons
     *         Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
     * Parameters:
     *         MeshDescription::FVertexInstanceID                 VertexInstanceID                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         BasicTypes::TArray<MeshDescription::FPolygonID>    OutConnectedPolygonIDs                                     (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
     *         void                                               ReturnValue
     */
    void UMeshDescriptionBase::GetVertexInstanceConnectedPolygons(const MeshDescription::FVertexInstanceID& VertexInstanceID, BasicTypes::TArray<MeshDescription::FPolygonID>* OutConnectedPolygonIDs)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/MeshDescription.MeshDescriptionBase.GetVertexInstanceConnectedPolygons");
        
        UMeshDescriptionBase_GetVertexInstanceConnectedPolygons_Params params {};
        params.VertexInstanceID = VertexInstanceID;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        if (OutConnectedPolygonIDs != nullptr)
            *OutConnectedPolygonIDs = params.OutConnectedPolygonIDs;
    }

    /**
     * Function:
     *         RVA    -> 0x04FB35A0
     *         Name   -> Function /Script/MeshDescription.MeshDescriptionBase.GetVertexCount
     *         Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
     * Parameters:
     *         int32_t                                            ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     */
    int32_t UMeshDescriptionBase::GetVertexCount()
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/MeshDescription.MeshDescriptionBase.GetVertexCount");
        
        UMeshDescriptionBase_GetVertexCount_Params params {};
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        return params.ReturnValue;
    }

    /**
     * Function:
     *         RVA    -> 0x04FAF6D0
     *         Name   -> Function /Script/MeshDescription.MeshDescriptionBase.GetVertexConnectedTriangles
     *         Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
     * Parameters:
     *         MeshDescription::FVertexID                         VertexID                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         BasicTypes::TArray<MeshDescription::FTriangleID>   OutConnectedTriangleIDs                                    (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
     *         void                                               ReturnValue
     */
    void UMeshDescriptionBase::GetVertexConnectedTriangles(const MeshDescription::FVertexID& VertexID, BasicTypes::TArray<MeshDescription::FTriangleID>* OutConnectedTriangleIDs)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/MeshDescription.MeshDescriptionBase.GetVertexConnectedTriangles");
        
        UMeshDescriptionBase_GetVertexConnectedTriangles_Params params {};
        params.VertexID = VertexID;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        if (OutConnectedTriangleIDs != nullptr)
            *OutConnectedTriangleIDs = params.OutConnectedTriangleIDs;
    }

    /**
     * Function:
     *         RVA    -> 0x04FAF380
     *         Name   -> Function /Script/MeshDescription.MeshDescriptionBase.GetVertexConnectedPolygons
     *         Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
     * Parameters:
     *         MeshDescription::FVertexID                         VertexID                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         BasicTypes::TArray<MeshDescription::FPolygonID>    OutConnectedPolygonIDs                                     (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
     *         void                                               ReturnValue
     */
    void UMeshDescriptionBase::GetVertexConnectedPolygons(const MeshDescription::FVertexID& VertexID, BasicTypes::TArray<MeshDescription::FPolygonID>* OutConnectedPolygonIDs)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/MeshDescription.MeshDescriptionBase.GetVertexConnectedPolygons");
        
        UMeshDescriptionBase_GetVertexConnectedPolygons_Params params {};
        params.VertexID = VertexID;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        if (OutConnectedPolygonIDs != nullptr)
            *OutConnectedPolygonIDs = params.OutConnectedPolygonIDs;
    }

    /**
     * Function:
     *         RVA    -> 0x04FAFE60
     *         Name   -> Function /Script/MeshDescription.MeshDescriptionBase.GetVertexConnectedEdges
     *         Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
     * Parameters:
     *         MeshDescription::FVertexID                         VertexID                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         BasicTypes::TArray<MeshDescription::FEdgeID>       OutEdgeIDs                                                 (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
     *         void                                               ReturnValue
     */
    void UMeshDescriptionBase::GetVertexConnectedEdges(const MeshDescription::FVertexID& VertexID, BasicTypes::TArray<MeshDescription::FEdgeID>* OutEdgeIDs)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/MeshDescription.MeshDescriptionBase.GetVertexConnectedEdges");
        
        UMeshDescriptionBase_GetVertexConnectedEdges_Params params {};
        params.VertexID = VertexID;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        if (OutEdgeIDs != nullptr)
            *OutEdgeIDs = params.OutEdgeIDs;
    }

    /**
     * Function:
     *         RVA    -> 0x04FAF000
     *         Name   -> Function /Script/MeshDescription.MeshDescriptionBase.GetVertexAdjacentVertices
     *         Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
     * Parameters:
     *         MeshDescription::FVertexID                         VertexID                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         BasicTypes::TArray<MeshDescription::FVertexID>     OutAdjacentVertexIDs                                       (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
     *         void                                               ReturnValue
     */
    void UMeshDescriptionBase::GetVertexAdjacentVertices(const MeshDescription::FVertexID& VertexID, BasicTypes::TArray<MeshDescription::FVertexID>* OutAdjacentVertexIDs)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/MeshDescription.MeshDescriptionBase.GetVertexAdjacentVertices");
        
        UMeshDescriptionBase_GetVertexAdjacentVertices_Params params {};
        params.VertexID = VertexID;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        if (OutAdjacentVertexIDs != nullptr)
            *OutAdjacentVertexIDs = params.OutAdjacentVertexIDs;
    }

    /**
     * Function:
     *         RVA    -> 0x04FAC3E0
     *         Name   -> Function /Script/MeshDescription.MeshDescriptionBase.GetTriangleVertices
     *         Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
     * Parameters:
     *         MeshDescription::FTriangleID                       TriangleID                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         BasicTypes::TArray<MeshDescription::FVertexID>     OutVertexIDs                                               (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
     *         void                                               ReturnValue
     */
    void UMeshDescriptionBase::GetTriangleVertices(const MeshDescription::FTriangleID& TriangleID, BasicTypes::TArray<MeshDescription::FVertexID>* OutVertexIDs)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/MeshDescription.MeshDescriptionBase.GetTriangleVertices");
        
        UMeshDescriptionBase_GetTriangleVertices_Params params {};
        params.TriangleID = TriangleID;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        if (OutVertexIDs != nullptr)
            *OutVertexIDs = params.OutVertexIDs;
    }

    /**
     * Function:
     *         RVA    -> 0x04FAC900
     *         Name   -> Function /Script/MeshDescription.MeshDescriptionBase.GetTriangleVertexInstances
     *         Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
     * Parameters:
     *         MeshDescription::FTriangleID                       TriangleID                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         BasicTypes::TArray<MeshDescription::FVertexInstanceID> OutVertexInstanceIDs                                       (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
     *         void                                               ReturnValue
     */
    void UMeshDescriptionBase::GetTriangleVertexInstances(const MeshDescription::FTriangleID& TriangleID, BasicTypes::TArray<MeshDescription::FVertexInstanceID>* OutVertexInstanceIDs)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/MeshDescription.MeshDescriptionBase.GetTriangleVertexInstances");
        
        UMeshDescriptionBase_GetTriangleVertexInstances_Params params {};
        params.TriangleID = TriangleID;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        if (OutVertexInstanceIDs != nullptr)
            *OutVertexInstanceIDs = params.OutVertexInstanceIDs;
    }

    /**
     * Function:
     *         RVA    -> 0x04FAC6A0
     *         Name   -> Function /Script/MeshDescription.MeshDescriptionBase.GetTriangleVertexInstance
     *         Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
     * Parameters:
     *         MeshDescription::FTriangleID                       TriangleID                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         int32_t                                            Index                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         MeshDescription::FVertexInstanceID                 ReturnValue                                                (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     */
    MeshDescription::FVertexInstanceID UMeshDescriptionBase::GetTriangleVertexInstance(const MeshDescription::FTriangleID& TriangleID, int32_t Index)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/MeshDescription.MeshDescriptionBase.GetTriangleVertexInstance");
        
        UMeshDescriptionBase_GetTriangleVertexInstance_Params params {};
        params.TriangleID = TriangleID;
        params.Index = Index;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        return params.ReturnValue;
    }

    /**
     * Function:
     *         RVA    -> 0x04FACD30
     *         Name   -> Function /Script/MeshDescription.MeshDescriptionBase.GetTrianglePolygonGroup
     *         Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
     * Parameters:
     *         MeshDescription::FTriangleID                       TriangleID                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         MeshDescription::FPolygonGroupID                   ReturnValue                                                (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     */
    MeshDescription::FPolygonGroupID UMeshDescriptionBase::GetTrianglePolygonGroup(const MeshDescription::FTriangleID& TriangleID)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/MeshDescription.MeshDescriptionBase.GetTrianglePolygonGroup");
        
        UMeshDescriptionBase_GetTrianglePolygonGroup_Params params {};
        params.TriangleID = TriangleID;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        return params.ReturnValue;
    }

    /**
     * Function:
     *         RVA    -> 0x04FACE90
     *         Name   -> Function /Script/MeshDescription.MeshDescriptionBase.GetTrianglePolygon
     *         Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
     * Parameters:
     *         MeshDescription::FTriangleID                       TriangleID                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         MeshDescription::FPolygonID                        ReturnValue                                                (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     */
    MeshDescription::FPolygonID UMeshDescriptionBase::GetTrianglePolygon(const MeshDescription::FTriangleID& TriangleID)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/MeshDescription.MeshDescriptionBase.GetTrianglePolygon");
        
        UMeshDescriptionBase_GetTrianglePolygon_Params params {};
        params.TriangleID = TriangleID;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        return params.ReturnValue;
    }

    /**
     * Function:
     *         RVA    -> 0x04FAC120
     *         Name   -> Function /Script/MeshDescription.MeshDescriptionBase.GetTriangleEdges
     *         Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
     * Parameters:
     *         MeshDescription::FTriangleID                       TriangleID                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         BasicTypes::TArray<MeshDescription::FEdgeID>       OutEdgeIDs                                                 (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
     *         void                                               ReturnValue
     */
    void UMeshDescriptionBase::GetTriangleEdges(const MeshDescription::FTriangleID& TriangleID, BasicTypes::TArray<MeshDescription::FEdgeID>* OutEdgeIDs)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/MeshDescription.MeshDescriptionBase.GetTriangleEdges");
        
        UMeshDescriptionBase_GetTriangleEdges_Params params {};
        params.TriangleID = TriangleID;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        if (OutEdgeIDs != nullptr)
            *OutEdgeIDs = params.OutEdgeIDs;
    }

    /**
     * Function:
     *         RVA    -> 0x04FB1700
     *         Name   -> Function /Script/MeshDescription.MeshDescriptionBase.GetTriangleCount
     *         Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
     * Parameters:
     *         int32_t                                            ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     */
    int32_t UMeshDescriptionBase::GetTriangleCount()
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/MeshDescription.MeshDescriptionBase.GetTriangleCount");
        
        UMeshDescriptionBase_GetTriangleCount_Params params {};
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        return params.ReturnValue;
    }

    /**
     * Function:
     *         RVA    -> 0x04FABF20
     *         Name   -> Function /Script/MeshDescription.MeshDescriptionBase.GetTriangleAdjacentTriangles
     *         Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
     * Parameters:
     *         MeshDescription::FTriangleID                       TriangleID                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         BasicTypes::TArray<MeshDescription::FTriangleID>   OutTriangleIDs                                             (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
     *         void                                               ReturnValue
     */
    void UMeshDescriptionBase::GetTriangleAdjacentTriangles(const MeshDescription::FTriangleID& TriangleID, BasicTypes::TArray<MeshDescription::FTriangleID>* OutTriangleIDs)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/MeshDescription.MeshDescriptionBase.GetTriangleAdjacentTriangles");
        
        UMeshDescriptionBase_GetTriangleAdjacentTriangles_Params params {};
        params.TriangleID = TriangleID;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        if (OutTriangleIDs != nullptr)
            *OutTriangleIDs = params.OutTriangleIDs;
    }

    /**
     * Function:
     *         RVA    -> 0x04FAB2E0
     *         Name   -> Function /Script/MeshDescription.MeshDescriptionBase.GetPolygonVertices
     *         Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
     * Parameters:
     *         MeshDescription::FPolygonID                        PolygonID                                                  (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         BasicTypes::TArray<MeshDescription::FVertexID>     OutVertexIDs                                               (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
     *         void                                               ReturnValue
     */
    void UMeshDescriptionBase::GetPolygonVertices(const MeshDescription::FPolygonID& PolygonID, BasicTypes::TArray<MeshDescription::FVertexID>* OutVertexIDs)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/MeshDescription.MeshDescriptionBase.GetPolygonVertices");
        
        UMeshDescriptionBase_GetPolygonVertices_Params params {};
        params.PolygonID = PolygonID;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        if (OutVertexIDs != nullptr)
            *OutVertexIDs = params.OutVertexIDs;
    }

    /**
     * Function:
     *         RVA    -> 0x04FAB640
     *         Name   -> Function /Script/MeshDescription.MeshDescriptionBase.GetPolygonVertexInstances
     *         Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
     * Parameters:
     *         MeshDescription::FPolygonID                        PolygonID                                                  (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         BasicTypes::TArray<MeshDescription::FVertexInstanceID> OutVertexInstanceIDs                                       (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
     *         void                                               ReturnValue
     */
    void UMeshDescriptionBase::GetPolygonVertexInstances(const MeshDescription::FPolygonID& PolygonID, BasicTypes::TArray<MeshDescription::FVertexInstanceID>* OutVertexInstanceIDs)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/MeshDescription.MeshDescriptionBase.GetPolygonVertexInstances");
        
        UMeshDescriptionBase_GetPolygonVertexInstances_Params params {};
        params.PolygonID = PolygonID;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        if (OutVertexInstanceIDs != nullptr)
            *OutVertexInstanceIDs = params.OutVertexInstanceIDs;
    }

    /**
     * Function:
     *         RVA    -> 0x04FABA00
     *         Name   -> Function /Script/MeshDescription.MeshDescriptionBase.GetPolygonTriangles
     *         Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
     * Parameters:
     *         MeshDescription::FPolygonID                        PolygonID                                                  (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         BasicTypes::TArray<MeshDescription::FTriangleID>   OutTriangleIDs                                             (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
     *         void                                               ReturnValue
     */
    void UMeshDescriptionBase::GetPolygonTriangles(const MeshDescription::FPolygonID& PolygonID, BasicTypes::TArray<MeshDescription::FTriangleID>* OutTriangleIDs)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/MeshDescription.MeshDescriptionBase.GetPolygonTriangles");
        
        UMeshDescriptionBase_GetPolygonTriangles_Params params {};
        params.PolygonID = PolygonID;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        if (OutTriangleIDs != nullptr)
            *OutTriangleIDs = params.OutTriangleIDs;
    }

    /**
     * Function:
     *         RVA    -> 0x04FAA890
     *         Name   -> Function /Script/MeshDescription.MeshDescriptionBase.GetPolygonPolygonGroup
     *         Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
     * Parameters:
     *         MeshDescription::FPolygonID                        PolygonID                                                  (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         MeshDescription::FPolygonGroupID                   ReturnValue                                                (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     */
    MeshDescription::FPolygonGroupID UMeshDescriptionBase::GetPolygonPolygonGroup(const MeshDescription::FPolygonID& PolygonID)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/MeshDescription.MeshDescriptionBase.GetPolygonPolygonGroup");
        
        UMeshDescriptionBase_GetPolygonPolygonGroup_Params params {};
        params.PolygonID = PolygonID;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        return params.ReturnValue;
    }

    /**
     * Function:
     *         RVA    -> 0x04FAB0E0
     *         Name   -> Function /Script/MeshDescription.MeshDescriptionBase.GetPolygonPerimeterEdges
     *         Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
     * Parameters:
     *         MeshDescription::FPolygonID                        PolygonID                                                  (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         BasicTypes::TArray<MeshDescription::FEdgeID>       OutEdgeIDs                                                 (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
     *         void                                               ReturnValue
     */
    void UMeshDescriptionBase::GetPolygonPerimeterEdges(const MeshDescription::FPolygonID& PolygonID, BasicTypes::TArray<MeshDescription::FEdgeID>* OutEdgeIDs)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/MeshDescription.MeshDescriptionBase.GetPolygonPerimeterEdges");
        
        UMeshDescriptionBase_GetPolygonPerimeterEdges_Params params {};
        params.PolygonID = PolygonID;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        if (OutEdgeIDs != nullptr)
            *OutEdgeIDs = params.OutEdgeIDs;
    }

    /**
     * Function:
     *         RVA    -> 0x04FAAEE0
     *         Name   -> Function /Script/MeshDescription.MeshDescriptionBase.GetPolygonInternalEdges
     *         Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
     * Parameters:
     *         MeshDescription::FPolygonID                        PolygonID                                                  (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         BasicTypes::TArray<MeshDescription::FEdgeID>       OutEdgeIDs                                                 (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
     *         void                                               ReturnValue
     */
    void UMeshDescriptionBase::GetPolygonInternalEdges(const MeshDescription::FPolygonID& PolygonID, BasicTypes::TArray<MeshDescription::FEdgeID>* OutEdgeIDs)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/MeshDescription.MeshDescriptionBase.GetPolygonInternalEdges");
        
        UMeshDescriptionBase_GetPolygonInternalEdges_Params params {};
        params.PolygonID = PolygonID;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        if (OutEdgeIDs != nullptr)
            *OutEdgeIDs = params.OutEdgeIDs;
    }

    /**
     * Function:
     *         RVA    -> 0x04FA9C50
     *         Name   -> Function /Script/MeshDescription.MeshDescriptionBase.GetPolygonGroupPolygons
     *         Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
     * Parameters:
     *         MeshDescription::FPolygonGroupID                   PolygonGroupID                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         BasicTypes::TArray<MeshDescription::FPolygonID>    OutPolygonIDs                                              (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
     *         void                                               ReturnValue
     */
    void UMeshDescriptionBase::GetPolygonGroupPolygons(const MeshDescription::FPolygonGroupID& PolygonGroupID, BasicTypes::TArray<MeshDescription::FPolygonID>* OutPolygonIDs)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/MeshDescription.MeshDescriptionBase.GetPolygonGroupPolygons");
        
        UMeshDescriptionBase_GetPolygonGroupPolygons_Params params {};
        params.PolygonGroupID = PolygonGroupID;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        if (OutPolygonIDs != nullptr)
            *OutPolygonIDs = params.OutPolygonIDs;
    }

    /**
     * Function:
     *         RVA    -> 0x04FB0470
     *         Name   -> Function /Script/MeshDescription.MeshDescriptionBase.GetPolygonGroupCount
     *         Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
     * Parameters:
     *         int32_t                                            ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     */
    int32_t UMeshDescriptionBase::GetPolygonGroupCount()
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/MeshDescription.MeshDescriptionBase.GetPolygonGroupCount");
        
        UMeshDescriptionBase_GetPolygonGroupCount_Params params {};
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        return params.ReturnValue;
    }

    /**
     * Function:
     *         RVA    -> 0x04FB0A00
     *         Name   -> Function /Script/MeshDescription.MeshDescriptionBase.GetPolygonCount
     *         Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
     * Parameters:
     *         int32_t                                            ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     */
    int32_t UMeshDescriptionBase::GetPolygonCount()
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/MeshDescription.MeshDescriptionBase.GetPolygonCount");
        
        UMeshDescriptionBase_GetPolygonCount_Params params {};
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        return params.ReturnValue;
    }

    /**
     * Function:
     *         RVA    -> 0x04FAA9F0
     *         Name   -> Function /Script/MeshDescription.MeshDescriptionBase.GetPolygonAdjacentPolygons
     *         Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
     * Parameters:
     *         MeshDescription::FPolygonID                        PolygonID                                                  (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         BasicTypes::TArray<MeshDescription::FPolygonID>    OutPolygonIDs                                              (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
     *         void                                               ReturnValue
     */
    void UMeshDescriptionBase::GetPolygonAdjacentPolygons(const MeshDescription::FPolygonID& PolygonID, BasicTypes::TArray<MeshDescription::FPolygonID>* OutPolygonIDs)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/MeshDescription.MeshDescriptionBase.GetPolygonAdjacentPolygons");
        
        UMeshDescriptionBase_GetPolygonAdjacentPolygons_Params params {};
        params.PolygonID = PolygonID;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        if (OutPolygonIDs != nullptr)
            *OutPolygonIDs = params.OutPolygonIDs;
    }

    /**
     * Function:
     *         RVA    -> 0x04FAF8D0
     *         Name   -> Function /Script/MeshDescription.MeshDescriptionBase.GetNumVertexVertexInstances
     *         Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
     * Parameters:
     *         MeshDescription::FVertexID                         VertexID                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         int32_t                                            ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     */
    int32_t UMeshDescriptionBase::GetNumVertexVertexInstances(const MeshDescription::FVertexID& VertexID)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/MeshDescription.MeshDescriptionBase.GetNumVertexVertexInstances");
        
        UMeshDescriptionBase_GetNumVertexVertexInstances_Params params {};
        params.VertexID = VertexID;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        return params.ReturnValue;
    }

    /**
     * Function:
     *         RVA    -> 0x04FAE3A0
     *         Name   -> Function /Script/MeshDescription.MeshDescriptionBase.GetNumVertexInstanceConnectedTriangles
     *         Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
     * Parameters:
     *         MeshDescription::FVertexInstanceID                 VertexInstanceID                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         int32_t                                            ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     */
    int32_t UMeshDescriptionBase::GetNumVertexInstanceConnectedTriangles(const MeshDescription::FVertexInstanceID& VertexInstanceID)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/MeshDescription.MeshDescriptionBase.GetNumVertexInstanceConnectedTriangles");
        
        UMeshDescriptionBase_GetNumVertexInstanceConnectedTriangles_Params params {};
        params.VertexInstanceID = VertexInstanceID;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        return params.ReturnValue;
    }

    /**
     * Function:
     *         RVA    -> 0x04FAE010
     *         Name   -> Function /Script/MeshDescription.MeshDescriptionBase.GetNumVertexInstanceConnectedPolygons
     *         Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
     * Parameters:
     *         MeshDescription::FVertexInstanceID                 VertexInstanceID                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         int32_t                                            ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     */
    int32_t UMeshDescriptionBase::GetNumVertexInstanceConnectedPolygons(const MeshDescription::FVertexInstanceID& VertexInstanceID)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/MeshDescription.MeshDescriptionBase.GetNumVertexInstanceConnectedPolygons");
        
        UMeshDescriptionBase_GetNumVertexInstanceConnectedPolygons_Params params {};
        params.VertexInstanceID = VertexInstanceID;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        return params.ReturnValue;
    }

    /**
     * Function:
     *         RVA    -> 0x04FAF580
     *         Name   -> Function /Script/MeshDescription.MeshDescriptionBase.GetNumVertexConnectedTriangles
     *         Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
     * Parameters:
     *         MeshDescription::FVertexID                         VertexID                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         int32_t                                            ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     */
    int32_t UMeshDescriptionBase::GetNumVertexConnectedTriangles(const MeshDescription::FVertexID& VertexID)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/MeshDescription.MeshDescriptionBase.GetNumVertexConnectedTriangles");
        
        UMeshDescriptionBase_GetNumVertexConnectedTriangles_Params params {};
        params.VertexID = VertexID;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        return params.ReturnValue;
    }

    /**
     * Function:
     *         RVA    -> 0x04FAF200
     *         Name   -> Function /Script/MeshDescription.MeshDescriptionBase.GetNumVertexConnectedPolygons
     *         Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
     * Parameters:
     *         MeshDescription::FVertexID                         VertexID                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         int32_t                                            ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     */
    int32_t UMeshDescriptionBase::GetNumVertexConnectedPolygons(const MeshDescription::FVertexID& VertexID)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/MeshDescription.MeshDescriptionBase.GetNumVertexConnectedPolygons");
        
        UMeshDescriptionBase_GetNumVertexConnectedPolygons_Params params {};
        params.VertexID = VertexID;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        return params.ReturnValue;
    }

    /**
     * Function:
     *         RVA    -> 0x04FAFCE0
     *         Name   -> Function /Script/MeshDescription.MeshDescriptionBase.GetNumVertexConnectedEdges
     *         Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
     * Parameters:
     *         MeshDescription::FVertexID                         VertexID                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         int32_t                                            ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     */
    int32_t UMeshDescriptionBase::GetNumVertexConnectedEdges(const MeshDescription::FVertexID& VertexID)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/MeshDescription.MeshDescriptionBase.GetNumVertexConnectedEdges");
        
        UMeshDescriptionBase_GetNumVertexConnectedEdges_Params params {};
        params.VertexID = VertexID;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        return params.ReturnValue;
    }

    /**
     * Function:
     *         RVA    -> 0x04FAB4E0
     *         Name   -> Function /Script/MeshDescription.MeshDescriptionBase.GetNumPolygonVertices
     *         Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
     * Parameters:
     *         MeshDescription::FPolygonID                        PolygonID                                                  (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         int32_t                                            ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     */
    int32_t UMeshDescriptionBase::GetNumPolygonVertices(const MeshDescription::FPolygonID& PolygonID)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/MeshDescription.MeshDescriptionBase.GetNumPolygonVertices");
        
        UMeshDescriptionBase_GetNumPolygonVertices_Params params {};
        params.PolygonID = PolygonID;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        return params.ReturnValue;
    }

    /**
     * Function:
     *         RVA    -> 0x04FAB880
     *         Name   -> Function /Script/MeshDescription.MeshDescriptionBase.GetNumPolygonTriangles
     *         Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
     * Parameters:
     *         MeshDescription::FPolygonID                        PolygonID                                                  (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         int32_t                                            ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     */
    int32_t UMeshDescriptionBase::GetNumPolygonTriangles(const MeshDescription::FPolygonID& PolygonID)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/MeshDescription.MeshDescriptionBase.GetNumPolygonTriangles");
        
        UMeshDescriptionBase_GetNumPolygonTriangles_Params params {};
        params.PolygonID = PolygonID;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        return params.ReturnValue;
    }

    /**
     * Function:
     *         RVA    -> 0x04FAAD50
     *         Name   -> Function /Script/MeshDescription.MeshDescriptionBase.GetNumPolygonInternalEdges
     *         Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
     * Parameters:
     *         MeshDescription::FPolygonID                        PolygonID                                                  (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         int32_t                                            ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     */
    int32_t UMeshDescriptionBase::GetNumPolygonInternalEdges(const MeshDescription::FPolygonID& PolygonID)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/MeshDescription.MeshDescriptionBase.GetNumPolygonInternalEdges");
        
        UMeshDescriptionBase_GetNumPolygonInternalEdges_Params params {};
        params.PolygonID = PolygonID;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        return params.ReturnValue;
    }

    /**
     * Function:
     *         RVA    -> 0x04FA9AF0
     *         Name   -> Function /Script/MeshDescription.MeshDescriptionBase.GetNumPolygonGroupPolygons
     *         Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
     * Parameters:
     *         MeshDescription::FPolygonGroupID                   PolygonGroupID                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         int32_t                                            ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     */
    int32_t UMeshDescriptionBase::GetNumPolygonGroupPolygons(const MeshDescription::FPolygonGroupID& PolygonGroupID)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/MeshDescription.MeshDescriptionBase.GetNumPolygonGroupPolygons");
        
        UMeshDescriptionBase_GetNumPolygonGroupPolygons_Params params {};
        params.PolygonGroupID = PolygonGroupID;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        return params.ReturnValue;
    }

    /**
     * Function:
     *         RVA    -> 0x04FAD860
     *         Name   -> Function /Script/MeshDescription.MeshDescriptionBase.GetNumEdgeConnectedTriangles
     *         Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
     * Parameters:
     *         MeshDescription::FEdgeID                           EdgeID                                                     (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         int32_t                                            ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     */
    int32_t UMeshDescriptionBase::GetNumEdgeConnectedTriangles(const MeshDescription::FEdgeID& EdgeID)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/MeshDescription.MeshDescriptionBase.GetNumEdgeConnectedTriangles");
        
        UMeshDescriptionBase_GetNumEdgeConnectedTriangles_Params params {};
        params.EdgeID = EdgeID;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        return params.ReturnValue;
    }

    /**
     * Function:
     *         RVA    -> 0x04FAD4D0
     *         Name   -> Function /Script/MeshDescription.MeshDescriptionBase.GetNumEdgeConnectedPolygons
     *         Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
     * Parameters:
     *         MeshDescription::FEdgeID                           EdgeID                                                     (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         int32_t                                            ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     */
    int32_t UMeshDescriptionBase::GetNumEdgeConnectedPolygons(const MeshDescription::FEdgeID& EdgeID)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/MeshDescription.MeshDescriptionBase.GetNumEdgeConnectedPolygons");
        
        UMeshDescriptionBase_GetNumEdgeConnectedPolygons_Params params {};
        params.EdgeID = EdgeID;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        return params.ReturnValue;
    }

    /**
     * Function:
     *         RVA    -> 0x04FACFF0
     *         Name   -> Function /Script/MeshDescription.MeshDescriptionBase.GetEdgeVertices
     *         Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
     * Parameters:
     *         MeshDescription::FEdgeID                           EdgeID                                                     (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         BasicTypes::TArray<MeshDescription::FVertexID>     OutVertexIDs                                               (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
     *         void                                               ReturnValue
     */
    void UMeshDescriptionBase::GetEdgeVertices(const MeshDescription::FEdgeID& EdgeID, BasicTypes::TArray<MeshDescription::FVertexID>* OutVertexIDs)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/MeshDescription.MeshDescriptionBase.GetEdgeVertices");
        
        UMeshDescriptionBase_GetEdgeVertices_Params params {};
        params.EdgeID = EdgeID;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        if (OutVertexIDs != nullptr)
            *OutVertexIDs = params.OutVertexIDs;
    }

    /**
     * Function:
     *         RVA    -> 0x04FAD270
     *         Name   -> Function /Script/MeshDescription.MeshDescriptionBase.GetEdgeVertex
     *         Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
     * Parameters:
     *         MeshDescription::FEdgeID                           EdgeID                                                     (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         int32_t                                            VertexNumber                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         MeshDescription::FVertexID                         ReturnValue                                                (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     */
    MeshDescription::FVertexID UMeshDescriptionBase::GetEdgeVertex(const MeshDescription::FEdgeID& EdgeID, int32_t VertexNumber)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/MeshDescription.MeshDescriptionBase.GetEdgeVertex");
        
        UMeshDescriptionBase_GetEdgeVertex_Params params {};
        params.EdgeID = EdgeID;
        params.VertexNumber = VertexNumber;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        return params.ReturnValue;
    }

    /**
     * Function:
     *         RVA    -> 0x04FB2400
     *         Name   -> Function /Script/MeshDescription.MeshDescriptionBase.GetEdgeCount
     *         Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
     * Parameters:
     *         int32_t                                            ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     */
    int32_t UMeshDescriptionBase::GetEdgeCount()
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/MeshDescription.MeshDescriptionBase.GetEdgeCount");
        
        UMeshDescriptionBase_GetEdgeCount_Params params {};
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        return params.ReturnValue;
    }

    /**
     * Function:
     *         RVA    -> 0x04FAD9E0
     *         Name   -> Function /Script/MeshDescription.MeshDescriptionBase.GetEdgeConnectedTriangles
     *         Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
     * Parameters:
     *         MeshDescription::FEdgeID                           EdgeID                                                     (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         BasicTypes::TArray<MeshDescription::FTriangleID>   OutConnectedTriangleIDs                                    (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
     *         void                                               ReturnValue
     */
    void UMeshDescriptionBase::GetEdgeConnectedTriangles(const MeshDescription::FEdgeID& EdgeID, BasicTypes::TArray<MeshDescription::FTriangleID>* OutConnectedTriangleIDs)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/MeshDescription.MeshDescriptionBase.GetEdgeConnectedTriangles");
        
        UMeshDescriptionBase_GetEdgeConnectedTriangles_Params params {};
        params.EdgeID = EdgeID;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        if (OutConnectedTriangleIDs != nullptr)
            *OutConnectedTriangleIDs = params.OutConnectedTriangleIDs;
    }

    /**
     * Function:
     *         RVA    -> 0x04FAD660
     *         Name   -> Function /Script/MeshDescription.MeshDescriptionBase.GetEdgeConnectedPolygons
     *         Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
     * Parameters:
     *         MeshDescription::FEdgeID                           EdgeID                                                     (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         BasicTypes::TArray<MeshDescription::FPolygonID>    OutConnectedPolygonIDs                                     (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
     *         void                                               ReturnValue
     */
    void UMeshDescriptionBase::GetEdgeConnectedPolygons(const MeshDescription::FEdgeID& EdgeID, BasicTypes::TArray<MeshDescription::FPolygonID>* OutConnectedPolygonIDs)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/MeshDescription.MeshDescriptionBase.GetEdgeConnectedPolygons");
        
        UMeshDescriptionBase_GetEdgeConnectedPolygons_Params params {};
        params.EdgeID = EdgeID;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        if (OutConnectedPolygonIDs != nullptr)
            *OutConnectedPolygonIDs = params.OutConnectedPolygonIDs;
    }

    /**
     * Function:
     *         RVA    -> 0x04FB3B30
     *         Name   -> Function /Script/MeshDescription.MeshDescriptionBase.Empty
     *         Flags  -> (Final, Native, Public, BlueprintCallable)
     * Parameters:
     *         void                                               ReturnValue
     */
    void UMeshDescriptionBase::Empty()
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/MeshDescription.MeshDescriptionBase.Empty");
        
        UMeshDescriptionBase_Empty_Params params {};
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
    }

    /**
     * Function:
     *         RVA    -> 0x04FB3000
     *         Name   -> Function /Script/MeshDescription.MeshDescriptionBase.DeleteVertexInstance
     *         Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
     * Parameters:
     *         MeshDescription::FVertexInstanceID                 VertexInstanceID                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         BasicTypes::TArray<MeshDescription::FVertexID>     OrphanedVertices                                           (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
     *         void                                               ReturnValue
     */
    void UMeshDescriptionBase::DeleteVertexInstance(const MeshDescription::FVertexInstanceID& VertexInstanceID, BasicTypes::TArray<MeshDescription::FVertexID>* OrphanedVertices)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/MeshDescription.MeshDescriptionBase.DeleteVertexInstance");
        
        UMeshDescriptionBase_DeleteVertexInstance_Params params {};
        params.VertexInstanceID = VertexInstanceID;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        if (OrphanedVertices != nullptr)
            *OrphanedVertices = params.OrphanedVertices;
    }

    /**
     * Function:
     *         RVA    -> 0x04FB3710
     *         Name   -> Function /Script/MeshDescription.MeshDescriptionBase.DeleteVertex
     *         Flags  -> (Final, Native, Public, BlueprintCallable)
     * Parameters:
     *         MeshDescription::FVertexID                         VertexID                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         void                                               ReturnValue
     */
    void UMeshDescriptionBase::DeleteVertex(const MeshDescription::FVertexID& VertexID)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/MeshDescription.MeshDescriptionBase.DeleteVertex");
        
        UMeshDescriptionBase_DeleteVertex_Params params {};
        params.VertexID = VertexID;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
    }

    /**
     * Function:
     *         RVA    -> 0x04FB1880
     *         Name   -> Function /Script/MeshDescription.MeshDescriptionBase.DeleteTriangle
     *         Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
     * Parameters:
     *         MeshDescription::FTriangleID                       TriangleID                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         BasicTypes::TArray<MeshDescription::FEdgeID>       OrphanedEdges                                              (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
     *         BasicTypes::TArray<MeshDescription::FVertexInstanceID> OrphanedVertexInstances                                    (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
     *         BasicTypes::TArray<MeshDescription::FPolygonGroupID> OrphanedPolygonGroupsPtr                                   (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
     *         void                                               ReturnValue
     */
    void UMeshDescriptionBase::DeleteTriangle(const MeshDescription::FTriangleID& TriangleID, BasicTypes::TArray<MeshDescription::FEdgeID>* OrphanedEdges, BasicTypes::TArray<MeshDescription::FVertexInstanceID>* OrphanedVertexInstances, BasicTypes::TArray<MeshDescription::FPolygonGroupID>* OrphanedPolygonGroupsPtr)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/MeshDescription.MeshDescriptionBase.DeleteTriangle");
        
        UMeshDescriptionBase_DeleteTriangle_Params params {};
        params.TriangleID = TriangleID;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        if (OrphanedEdges != nullptr)
            *OrphanedEdges = params.OrphanedEdges;
        if (OrphanedVertexInstances != nullptr)
            *OrphanedVertexInstances = params.OrphanedVertexInstances;
        if (OrphanedPolygonGroupsPtr != nullptr)
            *OrphanedPolygonGroupsPtr = params.OrphanedPolygonGroupsPtr;
    }

    /**
     * Function:
     *         RVA    -> 0x04FB05F0
     *         Name   -> Function /Script/MeshDescription.MeshDescriptionBase.DeletePolygonGroup
     *         Flags  -> (Final, Native, Public, BlueprintCallable)
     * Parameters:
     *         MeshDescription::FPolygonGroupID                   PolygonGroupID                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         void                                               ReturnValue
     */
    void UMeshDescriptionBase::DeletePolygonGroup(const MeshDescription::FPolygonGroupID& PolygonGroupID)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/MeshDescription.MeshDescriptionBase.DeletePolygonGroup");
        
        UMeshDescriptionBase_DeletePolygonGroup_Params params {};
        params.PolygonGroupID = PolygonGroupID;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
    }

    /**
     * Function:
     *         RVA    -> 0x04FB0B80
     *         Name   -> Function /Script/MeshDescription.MeshDescriptionBase.DeletePolygon
     *         Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
     * Parameters:
     *         MeshDescription::FPolygonID                        PolygonID                                                  (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         BasicTypes::TArray<MeshDescription::FEdgeID>       OrphanedEdges                                              (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
     *         BasicTypes::TArray<MeshDescription::FVertexInstanceID> OrphanedVertexInstances                                    (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
     *         BasicTypes::TArray<MeshDescription::FPolygonGroupID> OrphanedPolygonGroups                                      (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
     *         void                                               ReturnValue
     */
    void UMeshDescriptionBase::DeletePolygon(const MeshDescription::FPolygonID& PolygonID, BasicTypes::TArray<MeshDescription::FEdgeID>* OrphanedEdges, BasicTypes::TArray<MeshDescription::FVertexInstanceID>* OrphanedVertexInstances, BasicTypes::TArray<MeshDescription::FPolygonGroupID>* OrphanedPolygonGroups)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/MeshDescription.MeshDescriptionBase.DeletePolygon");
        
        UMeshDescriptionBase_DeletePolygon_Params params {};
        params.PolygonID = PolygonID;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        if (OrphanedEdges != nullptr)
            *OrphanedEdges = params.OrphanedEdges;
        if (OrphanedVertexInstances != nullptr)
            *OrphanedVertexInstances = params.OrphanedVertexInstances;
        if (OrphanedPolygonGroups != nullptr)
            *OrphanedPolygonGroups = params.OrphanedPolygonGroups;
    }

    /**
     * Function:
     *         RVA    -> 0x04FB2580
     *         Name   -> Function /Script/MeshDescription.MeshDescriptionBase.DeleteEdge
     *         Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
     * Parameters:
     *         MeshDescription::FEdgeID                           EdgeID                                                     (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         BasicTypes::TArray<MeshDescription::FVertexID>     OrphanedVertices                                           (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
     *         void                                               ReturnValue
     */
    void UMeshDescriptionBase::DeleteEdge(const MeshDescription::FEdgeID& EdgeID, BasicTypes::TArray<MeshDescription::FVertexID>* OrphanedVertices)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/MeshDescription.MeshDescriptionBase.DeleteEdge");
        
        UMeshDescriptionBase_DeleteEdge_Params params {};
        params.EdgeID = EdgeID;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        if (OrphanedVertices != nullptr)
            *OrphanedVertices = params.OrphanedVertices;
    }

    /**
     * Function:
     *         RVA    -> 0x04FB3850
     *         Name   -> Function /Script/MeshDescription.MeshDescriptionBase.CreateVertexWithID
     *         Flags  -> (Final, Native, Public, BlueprintCallable)
     * Parameters:
     *         MeshDescription::FVertexID                         VertexID                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         void                                               ReturnValue
     */
    void UMeshDescriptionBase::CreateVertexWithID(const MeshDescription::FVertexID& VertexID)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/MeshDescription.MeshDescriptionBase.CreateVertexWithID");
        
        UMeshDescriptionBase_CreateVertexWithID_Params params {};
        params.VertexID = VertexID;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
    }

    /**
     * Function:
     *         RVA    -> 0x04FB3200
     *         Name   -> Function /Script/MeshDescription.MeshDescriptionBase.CreateVertexInstanceWithID
     *         Flags  -> (Final, Native, Public, BlueprintCallable)
     * Parameters:
     *         MeshDescription::FVertexInstanceID                 VertexInstanceID                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         MeshDescription::FVertexID                         VertexID                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         void                                               ReturnValue
     */
    void UMeshDescriptionBase::CreateVertexInstanceWithID(const MeshDescription::FVertexInstanceID& VertexInstanceID, const MeshDescription::FVertexID& VertexID)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/MeshDescription.MeshDescriptionBase.CreateVertexInstanceWithID");
        
        UMeshDescriptionBase_CreateVertexInstanceWithID_Params params {};
        params.VertexInstanceID = VertexInstanceID;
        params.VertexID = VertexID;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
    }

    /**
     * Function:
     *         RVA    -> 0x04FB3450
     *         Name   -> Function /Script/MeshDescription.MeshDescriptionBase.CreateVertexInstance
     *         Flags  -> (Final, Native, Public, BlueprintCallable)
     * Parameters:
     *         MeshDescription::FVertexID                         VertexID                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         MeshDescription::FVertexInstanceID                 ReturnValue                                                (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     */
    MeshDescription::FVertexInstanceID UMeshDescriptionBase::CreateVertexInstance(const MeshDescription::FVertexID& VertexID)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/MeshDescription.MeshDescriptionBase.CreateVertexInstance");
        
        UMeshDescriptionBase_CreateVertexInstance_Params params {};
        params.VertexID = VertexID;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        return params.ReturnValue;
    }

    /**
     * Function:
     *         RVA    -> 0x04FB3980
     *         Name   -> Function /Script/MeshDescription.MeshDescriptionBase.CreateVertex
     *         Flags  -> (Final, Native, Public, BlueprintCallable)
     * Parameters:
     *         MeshDescription::FVertexID                         ReturnValue                                                (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     */
    MeshDescription::FVertexID UMeshDescriptionBase::CreateVertex()
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/MeshDescription.MeshDescriptionBase.CreateVertex");
        
        UMeshDescriptionBase_CreateVertex_Params params {};
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        return params.ReturnValue;
    }

    /**
     * Function:
     *         RVA    -> 0x04FB1BE0
     *         Name   -> Function /Script/MeshDescription.MeshDescriptionBase.CreateTriangleWithID
     *         Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
     * Parameters:
     *         MeshDescription::FTriangleID                       TriangleID                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         MeshDescription::FPolygonGroupID                   PolygonGroupID                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         BasicTypes::TArray<MeshDescription::FVertexInstanceID> VertexInstanceIDs                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
     *         BasicTypes::TArray<MeshDescription::FEdgeID>       NewEdgeIDs                                                 (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
     *         void                                               ReturnValue
     */
    void UMeshDescriptionBase::CreateTriangleWithID(const MeshDescription::FTriangleID& TriangleID, const MeshDescription::FPolygonGroupID& PolygonGroupID, BasicTypes::TArray<MeshDescription::FVertexInstanceID> VertexInstanceIDs, BasicTypes::TArray<MeshDescription::FEdgeID>* NewEdgeIDs)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/MeshDescription.MeshDescriptionBase.CreateTriangleWithID");
        
        UMeshDescriptionBase_CreateTriangleWithID_Params params {};
        params.TriangleID = TriangleID;
        params.PolygonGroupID = PolygonGroupID;
        params.VertexInstanceIDs = VertexInstanceIDs;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        if (NewEdgeIDs != nullptr)
            *NewEdgeIDs = params.NewEdgeIDs;
    }

    /**
     * Function:
     *         RVA    -> 0x04FB1FA0
     *         Name   -> Function /Script/MeshDescription.MeshDescriptionBase.CreateTriangle
     *         Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
     * Parameters:
     *         MeshDescription::FPolygonGroupID                   PolygonGroupID                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         BasicTypes::TArray<MeshDescription::FVertexInstanceID> VertexInstanceIDs                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
     *         BasicTypes::TArray<MeshDescription::FEdgeID>       NewEdgeIDs                                                 (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
     *         MeshDescription::FTriangleID                       ReturnValue                                                (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     */
    MeshDescription::FTriangleID UMeshDescriptionBase::CreateTriangle(const MeshDescription::FPolygonGroupID& PolygonGroupID, BasicTypes::TArray<MeshDescription::FVertexInstanceID> VertexInstanceIDs, BasicTypes::TArray<MeshDescription::FEdgeID>* NewEdgeIDs)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/MeshDescription.MeshDescriptionBase.CreateTriangle");
        
        UMeshDescriptionBase_CreateTriangle_Params params {};
        params.PolygonGroupID = PolygonGroupID;
        params.VertexInstanceIDs = VertexInstanceIDs;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        if (NewEdgeIDs != nullptr)
            *NewEdgeIDs = params.NewEdgeIDs;
        
        return params.ReturnValue;
    }

    /**
     * Function:
     *         RVA    -> 0x04FB0EE0
     *         Name   -> Function /Script/MeshDescription.MeshDescriptionBase.CreatePolygonWithID
     *         Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
     * Parameters:
     *         MeshDescription::FPolygonID                        PolygonID                                                  (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         MeshDescription::FPolygonGroupID                   PolygonGroupID                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         BasicTypes::TArray<MeshDescription::FVertexInstanceID> VertexInstanceIDs                                          (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
     *         BasicTypes::TArray<MeshDescription::FEdgeID>       NewEdgeIDs                                                 (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
     *         void                                               ReturnValue
     */
    void UMeshDescriptionBase::CreatePolygonWithID(const MeshDescription::FPolygonID& PolygonID, const MeshDescription::FPolygonGroupID& PolygonGroupID, BasicTypes::TArray<MeshDescription::FVertexInstanceID>* VertexInstanceIDs, BasicTypes::TArray<MeshDescription::FEdgeID>* NewEdgeIDs)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/MeshDescription.MeshDescriptionBase.CreatePolygonWithID");
        
        UMeshDescriptionBase_CreatePolygonWithID_Params params {};
        params.PolygonID = PolygonID;
        params.PolygonGroupID = PolygonGroupID;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        if (VertexInstanceIDs != nullptr)
            *VertexInstanceIDs = params.VertexInstanceIDs;
        if (NewEdgeIDs != nullptr)
            *NewEdgeIDs = params.NewEdgeIDs;
    }

    /**
     * Function:
     *         RVA    -> 0x04FB0730
     *         Name   -> Function /Script/MeshDescription.MeshDescriptionBase.CreatePolygonGroupWithID
     *         Flags  -> (Final, Native, Public, BlueprintCallable)
     * Parameters:
     *         MeshDescription::FPolygonGroupID                   PolygonGroupID                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         void                                               ReturnValue
     */
    void UMeshDescriptionBase::CreatePolygonGroupWithID(const MeshDescription::FPolygonGroupID& PolygonGroupID)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/MeshDescription.MeshDescriptionBase.CreatePolygonGroupWithID");
        
        UMeshDescriptionBase_CreatePolygonGroupWithID_Params params {};
        params.PolygonGroupID = PolygonGroupID;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
    }

    /**
     * Function:
     *         RVA    -> 0x04FB0870
     *         Name   -> Function /Script/MeshDescription.MeshDescriptionBase.CreatePolygonGroup
     *         Flags  -> (Final, Native, Public, BlueprintCallable)
     * Parameters:
     *         MeshDescription::FPolygonGroupID                   ReturnValue                                                (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     */
    MeshDescription::FPolygonGroupID UMeshDescriptionBase::CreatePolygonGroup()
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/MeshDescription.MeshDescriptionBase.CreatePolygonGroup");
        
        UMeshDescriptionBase_CreatePolygonGroup_Params params {};
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        return params.ReturnValue;
    }

    /**
     * Function:
     *         RVA    -> 0x04FB12A0
     *         Name   -> Function /Script/MeshDescription.MeshDescriptionBase.CreatePolygon
     *         Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
     * Parameters:
     *         MeshDescription::FPolygonGroupID                   PolygonGroupID                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         BasicTypes::TArray<MeshDescription::FVertexInstanceID> VertexInstanceIDs                                          (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
     *         BasicTypes::TArray<MeshDescription::FEdgeID>       NewEdgeIDs                                                 (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
     *         MeshDescription::FPolygonID                        ReturnValue                                                (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     */
    MeshDescription::FPolygonID UMeshDescriptionBase::CreatePolygon(const MeshDescription::FPolygonGroupID& PolygonGroupID, BasicTypes::TArray<MeshDescription::FVertexInstanceID>* VertexInstanceIDs, BasicTypes::TArray<MeshDescription::FEdgeID>* NewEdgeIDs)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/MeshDescription.MeshDescriptionBase.CreatePolygon");
        
        UMeshDescriptionBase_CreatePolygon_Params params {};
        params.PolygonGroupID = PolygonGroupID;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        if (VertexInstanceIDs != nullptr)
            *VertexInstanceIDs = params.VertexInstanceIDs;
        if (NewEdgeIDs != nullptr)
            *NewEdgeIDs = params.NewEdgeIDs;
        
        return params.ReturnValue;
    }

    /**
     * Function:
     *         RVA    -> 0x04FB2780
     *         Name   -> Function /Script/MeshDescription.MeshDescriptionBase.CreateEdgeWithID
     *         Flags  -> (Final, Native, Public, BlueprintCallable)
     * Parameters:
     *         MeshDescription::FEdgeID                           EdgeID                                                     (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         MeshDescription::FVertexID                         VertexID0                                                  (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         MeshDescription::FVertexID                         VertexID1                                                  (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         void                                               ReturnValue
     */
    void UMeshDescriptionBase::CreateEdgeWithID(const MeshDescription::FEdgeID& EdgeID, const MeshDescription::FVertexID& VertexID0, const MeshDescription::FVertexID& VertexID1)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/MeshDescription.MeshDescriptionBase.CreateEdgeWithID");
        
        UMeshDescriptionBase_CreateEdgeWithID_Params params {};
        params.EdgeID = EdgeID;
        params.VertexID0 = VertexID0;
        params.VertexID1 = VertexID1;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
    }

    /**
     * Function:
     *         RVA    -> 0x04FB2B10
     *         Name   -> Function /Script/MeshDescription.MeshDescriptionBase.CreateEdge
     *         Flags  -> (Final, Native, Public, BlueprintCallable)
     * Parameters:
     *         MeshDescription::FVertexID                         VertexID0                                                  (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         MeshDescription::FVertexID                         VertexID1                                                  (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         MeshDescription::FEdgeID                           ReturnValue                                                (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     */
    MeshDescription::FEdgeID UMeshDescriptionBase::CreateEdge(const MeshDescription::FVertexID& VertexID0, const MeshDescription::FVertexID& VertexID1)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/MeshDescription.MeshDescriptionBase.CreateEdge");
        
        UMeshDescriptionBase_CreateEdge_Params params {};
        params.VertexID0 = VertexID0;
        params.VertexID1 = VertexID1;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        return params.ReturnValue;
    }

    /**
     * Function:
     *         RVA    -> 0x04FA9EF0
     *         Name   -> Function /Script/MeshDescription.MeshDescriptionBase.ComputePolygonTriangulation
     *         Flags  -> (Final, Native, Public, BlueprintCallable)
     * Parameters:
     *         MeshDescription::FPolygonID                        PolygonID                                                  (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         void                                               ReturnValue
     */
    void UMeshDescriptionBase::ComputePolygonTriangulation(const MeshDescription::FPolygonID& PolygonID)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/MeshDescription.MeshDescriptionBase.ComputePolygonTriangulation");
        
        UMeshDescriptionBase_ComputePolygonTriangulation_Params params {};
        params.PolygonID = PolygonID;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
    }

}

#ifdef _MSC_VER
    #pragma pack(pop)
#endif
