/**
 * ----------------------------------------
 * |        Generated By CheatGear        |
 * ----------------------------------------
 * | Game:    TFDCG                       |
 * | Version: 1                           |
 * | Date:    08/22/2024                  |
 * ----------------------------------------
 */

#include "pch.h"
#include <cstdint>
#include <vector>
#include <string>
#include <locale>
#include <unordered_set>
#include "Headers/Global_DEFINES.h"
#include "Headers/BasicTypes.h"
#include "Headers/CoreUObject_UFunction.h"
#include "Headers/CalcDamageBase_PARAMS.h"
#include "Headers/CalcDamageBase_UCalcDamageBase_C.h"

#ifdef _MSC_VER
    #pragma pack(push, 0x01)
#endif

namespace CG::CalcDamageBase
{
    // --------------------------------------------------
    // # Structs functions
    // --------------------------------------------------
    /**
     * Function:
     *         RVA    -> 0x03A3F420
     *         Name   -> Function /Game/Blueprints/Gameplay/Common/Calculation/Damage/CalcDamageBase.CalcDamageBase_C.ApplySkillCritical
     *         Flags  -> (Protected, HasOutParms, HasDefaults, BlueprintCallable, BlueprintEvent, Const)
     * Parameters:
     *         M1::FM1AbilityOpCalcParam                          Param                                                      (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, NoDestructor)
     *         M1::FM1CalcDamageInfo                              DamageInfo                                                 (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, ContainsInstancedReference)
     *         void                                               ReturnValue
     */
    void UCalcDamageBase_C::ApplySkillCritical(M1::FM1AbilityOpCalcParam* Param, M1::FM1CalcDamageInfo* DamageInfo)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Game/Blueprints/Gameplay/Common/Calculation/Damage/CalcDamageBase.CalcDamageBase_C.ApplySkillCritical");
        
        UCalcDamageBase_C_ApplySkillCritical_Params params {};
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        if (Param != nullptr)
            *Param = params.Param;
        if (DamageInfo != nullptr)
            *DamageInfo = params.DamageInfo;
    }

    /**
     * Function:
     *         RVA    -> 0x03A3F420
     *         Name   -> Function /Game/Blueprints/Gameplay/Common/Calculation/Damage/CalcDamageBase.CalcDamageBase_C.Determine Skill Critical
     *         Flags  -> (Protected, HasOutParms, HasDefaults, BlueprintCallable, BlueprintEvent, Const)
     * Parameters:
     *         M1::FM1AbilityOpCalcParam                          Param                                                      (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, NoDestructor)
     *         M1::FM1CalcDamageInfo                              DamageInfo                                                 (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, ContainsInstancedReference)
     *         void                                               ReturnValue
     */
    void UCalcDamageBase_C::DetermineSkillCritical(M1::FM1AbilityOpCalcParam* Param, M1::FM1CalcDamageInfo* DamageInfo)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Game/Blueprints/Gameplay/Common/Calculation/Damage/CalcDamageBase.CalcDamageBase_C.Determine Skill Critical");
        
        UCalcDamageBase_C_DetermineSkillCritical_Params params {};
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        if (Param != nullptr)
            *Param = params.Param;
        if (DamageInfo != nullptr)
            *DamageInfo = params.DamageInfo;
    }

    /**
     * Function:
     *         RVA    -> 0x03A3F420
     *         Name   -> Function /Game/Blueprints/Gameplay/Common/Calculation/Damage/CalcDamageBase.CalcDamageBase_C.DetermineElemetalDEF
     *         Flags  -> (Protected, HasOutParms, HasDefaults, BlueprintCallable, BlueprintEvent, Const)
     * Parameters:
     *         M1::FM1AbilityOpCalcParam                          Param                                                      (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, NoDestructor)
     *         M1Data::EM1ElementalDamageChannel                  ElementalChannel                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
     *         M1Data::FM1ScaledInteger                           ElementalDEF                                               (Parm, OutParm, NoDestructor, HasGetValueTypeHash)
     *         void                                               ReturnValue
     */
    void UCalcDamageBase_C::DetermineElemetalDEF(M1::FM1AbilityOpCalcParam* Param, M1Data::EM1ElementalDamageChannel ElementalChannel, M1Data::FM1ScaledInteger* ElementalDEF)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Game/Blueprints/Gameplay/Common/Calculation/Damage/CalcDamageBase.CalcDamageBase_C.DetermineElemetalDEF");
        
        UCalcDamageBase_C_DetermineElemetalDEF_Params params {};
        params.ElementalChannel = ElementalChannel;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        if (Param != nullptr)
            *Param = params.Param;
        if (ElementalDEF != nullptr)
            *ElementalDEF = params.ElementalDEF;
    }

    /**
     * Function:
     *         RVA    -> 0x03A3F420
     *         Name   -> Function /Game/Blueprints/Gameplay/Common/Calculation/Damage/CalcDamageBase.CalcDamageBase_C.Determine Monster SkillDEF
     *         Flags  -> (Protected, HasOutParms, HasDefaults, BlueprintCallable, BlueprintEvent, Const)
     * Parameters:
     *         M1::FM1AbilityOpCalcParam                          Param                                                      (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, NoDestructor)
     *         M1Data::FM1ScaledInteger                           SkillDEF                                                   (Parm, OutParm, NoDestructor, HasGetValueTypeHash)
     *         void                                               ReturnValue
     */
    void UCalcDamageBase_C::DetermineMonsterSkillDEF(M1::FM1AbilityOpCalcParam* Param, M1Data::FM1ScaledInteger* SkillDEF)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Game/Blueprints/Gameplay/Common/Calculation/Damage/CalcDamageBase.CalcDamageBase_C.Determine Monster SkillDEF");
        
        UCalcDamageBase_C_DetermineMonsterSkillDEF_Params params {};
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        if (Param != nullptr)
            *Param = params.Param;
        if (SkillDEF != nullptr)
            *SkillDEF = params.SkillDEF;
    }

    /**
     * Function:
     *         RVA    -> 0x03A3F420
     *         Name   -> Function /Game/Blueprints/Gameplay/Common/Calculation/Damage/CalcDamageBase.CalcDamageBase_C.DetermineGaugeStatMultiplier
     *         Flags  -> (Protected, HasOutParms, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
     * Parameters:
     *         M1::FM1AbilityOpCalcParam                          Param                                                      (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, NoDestructor)
     *         M1Data::EM1StatType                                WatchStat                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
     *         M1Data::EM1StatType                                MaxStat                                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
     *         BasicTypes::FName                                  MinValue                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
     *         BasicTypes::FName                                  MaxValue                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
     *         BasicTypes::FName                                  AddPower                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
     *         BasicTypes::FName                                  AddAttack                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
     *         M1Data::FM1ScaledInteger                           AddPowerValue                                              (Parm, OutParm, NoDestructor, HasGetValueTypeHash)
     *         M1Data::FM1ScaledInteger                           AddAttackValue                                             (Parm, OutParm, NoDestructor, HasGetValueTypeHash)
     *         void                                               ReturnValue
     */
    void UCalcDamageBase_C::DetermineGaugeStatMultiplier(M1::FM1AbilityOpCalcParam* Param, M1Data::EM1StatType WatchStat, M1Data::EM1StatType MaxStat, const BasicTypes::FName& MinValue, const BasicTypes::FName& MaxValue, const BasicTypes::FName& AddPower, const BasicTypes::FName& AddAttack, M1Data::FM1ScaledInteger* AddPowerValue, M1Data::FM1ScaledInteger* AddAttackValue)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Game/Blueprints/Gameplay/Common/Calculation/Damage/CalcDamageBase.CalcDamageBase_C.DetermineGaugeStatMultiplier");
        
        UCalcDamageBase_C_DetermineGaugeStatMultiplier_Params params {};
        params.WatchStat = WatchStat;
        params.MaxStat = MaxStat;
        params.MinValue = MinValue;
        params.MaxValue = MaxValue;
        params.AddPower = AddPower;
        params.AddAttack = AddAttack;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        if (Param != nullptr)
            *Param = params.Param;
        if (AddPowerValue != nullptr)
            *AddPowerValue = params.AddPowerValue;
        if (AddAttackValue != nullptr)
            *AddAttackValue = params.AddAttackValue;
    }

    /**
     * Function:
     *         RVA    -> 0x03A3F420
     *         Name   -> Function /Game/Blueprints/Gameplay/Common/Calculation/Damage/CalcDamageBase.CalcDamageBase_C.DetermineGaugeStatMultiplier_Bunny
     *         Flags  -> (Protected, HasOutParms, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
     * Parameters:
     *         M1::FM1AbilityOpCalcParam                          Param                                                      (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, NoDestructor)
     *         M1Data::EM1StatType                                WatchStat                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
     *         M1Data::EM1StatType                                MaxStat                                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
     *         BasicTypes::FName                                  MinValue                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
     *         BasicTypes::FName                                  MaxValue                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
     *         BasicTypes::FName                                  AddPower                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
     *         BasicTypes::FName                                  AddAttack                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
     *         M1Data::FM1ScaledInteger                           AddPowerValue                                              (Parm, OutParm, NoDestructor, HasGetValueTypeHash)
     *         M1Data::FM1ScaledInteger                           AddAttackValue                                             (Parm, OutParm, NoDestructor, HasGetValueTypeHash)
     *         void                                               ReturnValue
     */
    void UCalcDamageBase_C::DetermineGaugeStatMultiplier_Bunny(M1::FM1AbilityOpCalcParam* Param, M1Data::EM1StatType WatchStat, M1Data::EM1StatType MaxStat, const BasicTypes::FName& MinValue, const BasicTypes::FName& MaxValue, const BasicTypes::FName& AddPower, const BasicTypes::FName& AddAttack, M1Data::FM1ScaledInteger* AddPowerValue, M1Data::FM1ScaledInteger* AddAttackValue)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Game/Blueprints/Gameplay/Common/Calculation/Damage/CalcDamageBase.CalcDamageBase_C.DetermineGaugeStatMultiplier_Bunny");
        
        UCalcDamageBase_C_DetermineGaugeStatMultiplier_Bunny_Params params {};
        params.WatchStat = WatchStat;
        params.MaxStat = MaxStat;
        params.MinValue = MinValue;
        params.MaxValue = MaxValue;
        params.AddPower = AddPower;
        params.AddAttack = AddAttack;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        if (Param != nullptr)
            *Param = params.Param;
        if (AddPowerValue != nullptr)
            *AddPowerValue = params.AddPowerValue;
        if (AddAttackValue != nullptr)
            *AddAttackValue = params.AddAttackValue;
    }

    /**
     * Function:
     *         RVA    -> 0x03A3F420
     *         Name   -> Function /Game/Blueprints/Gameplay/Common/Calculation/Damage/CalcDamageBase.CalcDamageBase_C.Apply Skill ATK
     *         Flags  -> (Protected, HasOutParms, HasDefaults, BlueprintCallable, BlueprintEvent, Const)
     * Parameters:
     *         M1::FM1AbilityOpCalcParam                          Param                                                      (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, NoDestructor)
     *         M1::FM1CalcDamageInfo                              DamageInfo                                                 (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, ContainsInstancedReference)
     *         M1Data::EM1ElementalDamageChannel                  ElementalChannel                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
     *         M1Data::EM1SkillArcheType                          ArcheType                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
     *         M1Data::FM1ScaledInteger                           AddPower                                                   (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, HasGetValueTypeHash)
     *         M1Data::FM1ScaledInteger                           AddAttack                                                  (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, HasGetValueTypeHash)
     *         void                                               ReturnValue
     */
    void UCalcDamageBase_C::ApplySkillATK(M1::FM1AbilityOpCalcParam* Param, M1::FM1CalcDamageInfo* DamageInfo, M1Data::EM1ElementalDamageChannel ElementalChannel, M1Data::EM1SkillArcheType ArcheType, const M1Data::FM1ScaledInteger& AddPower, const M1Data::FM1ScaledInteger& AddAttack)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Game/Blueprints/Gameplay/Common/Calculation/Damage/CalcDamageBase.CalcDamageBase_C.Apply Skill ATK");
        
        UCalcDamageBase_C_ApplySkillATK_Params params {};
        params.ElementalChannel = ElementalChannel;
        params.ArcheType = ArcheType;
        params.AddPower = AddPower;
        params.AddAttack = AddAttack;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        if (Param != nullptr)
            *Param = params.Param;
        if (DamageInfo != nullptr)
            *DamageInfo = params.DamageInfo;
    }

    /**
     * Function:
     *         RVA    -> 0x03A3F420
     *         Name   -> Function /Game/Blueprints/Gameplay/Common/Calculation/Damage/CalcDamageBase.CalcDamageBase_C.ApplyDEFOnlyWeapon
     *         Flags  -> (Protected, HasOutParms, HasDefaults, BlueprintCallable, BlueprintEvent, Const)
     * Parameters:
     *         M1::FM1AbilityOpCalcParam                          Param                                                      (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, NoDestructor)
     *         M1::FM1CalcDamageInfo                              DamageInfo                                                 (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, ContainsInstancedReference)
     *         void                                               ReturnValue
     */
    void UCalcDamageBase_C::ApplyDEFOnlyWeapon(M1::FM1AbilityOpCalcParam* Param, M1::FM1CalcDamageInfo* DamageInfo)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Game/Blueprints/Gameplay/Common/Calculation/Damage/CalcDamageBase.CalcDamageBase_C.ApplyDEFOnlyWeapon");
        
        UCalcDamageBase_C_ApplyDEFOnlyWeapon_Params params {};
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        if (Param != nullptr)
            *Param = params.Param;
        if (DamageInfo != nullptr)
            *DamageInfo = params.DamageInfo;
    }

    /**
     * Function:
     *         RVA    -> 0x03A3F420
     *         Name   -> Function /Game/Blueprints/Gameplay/Common/Calculation/Damage/CalcDamageBase.CalcDamageBase_C.ApplyDamageCoefficient
     *         Flags  -> (Protected, HasOutParms, HasDefaults, BlueprintCallable, BlueprintEvent, Const)
     * Parameters:
     *         M1::FM1AbilityOpCalcParam                          Param                                                      (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, NoDestructor)
     *         M1::FM1CalcDamageInfo                              DamageInfo                                                 (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, ContainsInstancedReference)
     *         void                                               ReturnValue
     */
    void UCalcDamageBase_C::ApplyDamageCoefficient(M1::FM1AbilityOpCalcParam* Param, const M1::FM1CalcDamageInfo& DamageInfo)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Game/Blueprints/Gameplay/Common/Calculation/Damage/CalcDamageBase.CalcDamageBase_C.ApplyDamageCoefficient");
        
        UCalcDamageBase_C_ApplyDamageCoefficient_Params params {};
        params.DamageInfo = DamageInfo;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        if (Param != nullptr)
            *Param = params.Param;
    }

    /**
     * Function:
     *         RVA    -> 0x03A3F420
     *         Name   -> Function /Game/Blueprints/Gameplay/Common/Calculation/Damage/CalcDamageBase.CalcDamageBase_C.ApplyDEFWithInflection
     *         Flags  -> (Protected, HasOutParms, HasDefaults, BlueprintCallable, BlueprintEvent, Const)
     * Parameters:
     *         M1::FM1AbilityOpCalcParam                          Param                                                      (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, NoDestructor)
     *         M1::FM1CalcDamageInfo                              DamageInfo                                                 (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, ContainsInstancedReference)
     *         M1Data::FM1ScaledInteger                           AttackerLevelValue                                         (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, HasGetValueTypeHash)
     *         M1Data::FM1ScaledInteger                           DEFInflection_VarX1                                        (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, HasGetValueTypeHash)
     *         M1Data::FM1ScaledInteger                           DEFInflection_VarX2                                        (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, HasGetValueTypeHash)
     *         M1Data::FM1ScaledInteger                           DEFInflection_VarX3                                        (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, HasGetValueTypeHash)
     *         void                                               ReturnValue
     */
    void UCalcDamageBase_C::ApplyDEFWithInflection(M1::FM1AbilityOpCalcParam* Param, const M1::FM1CalcDamageInfo& DamageInfo, const M1Data::FM1ScaledInteger& AttackerLevelValue, const M1Data::FM1ScaledInteger& DEFInflection_VarX1, const M1Data::FM1ScaledInteger& DEFInflection_VarX2, const M1Data::FM1ScaledInteger& DEFInflection_VarX3)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Game/Blueprints/Gameplay/Common/Calculation/Damage/CalcDamageBase.CalcDamageBase_C.ApplyDEFWithInflection");
        
        UCalcDamageBase_C_ApplyDEFWithInflection_Params params {};
        params.DamageInfo = DamageInfo;
        params.AttackerLevelValue = AttackerLevelValue;
        params.DEFInflection_VarX1 = DEFInflection_VarX1;
        params.DEFInflection_VarX2 = DEFInflection_VarX2;
        params.DEFInflection_VarX3 = DEFInflection_VarX3;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        if (Param != nullptr)
            *Param = params.Param;
    }

    /**
     * Function:
     *         RVA    -> 0x03A3F420
     *         Name   -> Function /Game/Blueprints/Gameplay/Common/Calculation/Damage/CalcDamageBase.CalcDamageBase_C.ApplyInvokeChanceElementalSE
     *         Flags  -> (Protected, HasOutParms, HasDefaults, BlueprintCallable, BlueprintEvent, Const)
     * Parameters:
     *         M1::FM1AbilityOpCalcParam                          Param                                                      (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, NoDestructor)
     *         M1::FM1CalcDamageInfo                              DamageInfo                                                 (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, ContainsInstancedReference)
     *         void                                               ReturnValue
     */
    void UCalcDamageBase_C::ApplyInvokeChanceElementalSE(M1::FM1AbilityOpCalcParam* Param, const M1::FM1CalcDamageInfo& DamageInfo)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Game/Blueprints/Gameplay/Common/Calculation/Damage/CalcDamageBase.CalcDamageBase_C.ApplyInvokeChanceElementalSE");
        
        UCalcDamageBase_C_ApplyInvokeChanceElementalSE_Params params {};
        params.DamageInfo = DamageInfo;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        if (Param != nullptr)
            *Param = params.Param;
    }

    /**
     * Function:
     *         RVA    -> 0x03A3F420
     *         Name   -> Function /Game/Blueprints/Gameplay/Common/Calculation/Damage/CalcDamageBase.CalcDamageBase_C.ApplyATKMultiplierByExplosionRadius
     *         Flags  -> (Protected, HasOutParms, HasDefaults, BlueprintCallable, BlueprintEvent, Const)
     * Parameters:
     *         M1::FM1AbilityOpCalcParam                          Param                                                      (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, NoDestructor)
     *         M1::FM1CalcDamageInfo                              DamageInfo                                                 (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, ContainsInstancedReference)
     *         double                                             ExplosionRadius                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
     *         void                                               ReturnValue
     */
    void UCalcDamageBase_C::ApplyATKMultiplierByExplosionRadius(M1::FM1AbilityOpCalcParam* Param, M1::FM1CalcDamageInfo* DamageInfo, double ExplosionRadius)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Game/Blueprints/Gameplay/Common/Calculation/Damage/CalcDamageBase.CalcDamageBase_C.ApplyATKMultiplierByExplosionRadius");
        
        UCalcDamageBase_C_ApplyATKMultiplierByExplosionRadius_Params params {};
        params.ExplosionRadius = ExplosionRadius;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        if (Param != nullptr)
            *Param = params.Param;
        if (DamageInfo != nullptr)
            *DamageInfo = params.DamageInfo;
    }

    /**
     * Function:
     *         RVA    -> 0x03A3F420
     *         Name   -> Function /Game/Blueprints/Gameplay/Common/Calculation/Damage/CalcDamageBase.CalcDamageBase_C.ApplyCritical
     *         Flags  -> (Protected, HasOutParms, HasDefaults, BlueprintCallable, BlueprintEvent, Const)
     * Parameters:
     *         M1::FM1AbilityOpCalcParam                          Param                                                      (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, NoDestructor)
     *         M1::FM1CalcDamageInfo                              DamageInfo                                                 (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, ContainsInstancedReference)
     *         void                                               ReturnValue
     */
    void UCalcDamageBase_C::ApplyCritical(M1::FM1AbilityOpCalcParam* Param, const M1::FM1CalcDamageInfo& DamageInfo)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Game/Blueprints/Gameplay/Common/Calculation/Damage/CalcDamageBase.CalcDamageBase_C.ApplyCritical");
        
        UCalcDamageBase_C_ApplyCritical_Params params {};
        params.DamageInfo = DamageInfo;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        if (Param != nullptr)
            *Param = params.Param;
    }

    /**
     * Function:
     *         RVA    -> 0x03A3F420
     *         Name   -> Function /Game/Blueprints/Gameplay/Common/Calculation/Damage/CalcDamageBase.CalcDamageBase_C.ApplyATKMultiplierByCharge
     *         Flags  -> (Protected, HasOutParms, HasDefaults, BlueprintCallable, BlueprintEvent, Const)
     * Parameters:
     *         M1::FM1AbilityOpCalcParam                          Param                                                      (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, NoDestructor)
     *         M1::FM1CalcDamageInfo                              DanageInfo                                                 (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, ContainsInstancedReference)
     *         float                                              ATKMultiplierByCharge                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
     *         void                                               ReturnValue
     */
    void UCalcDamageBase_C::ApplyATKMultiplierByCharge(M1::FM1AbilityOpCalcParam* Param, const M1::FM1CalcDamageInfo& DanageInfo, float ATKMultiplierByCharge)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Game/Blueprints/Gameplay/Common/Calculation/Damage/CalcDamageBase.CalcDamageBase_C.ApplyATKMultiplierByCharge");
        
        UCalcDamageBase_C_ApplyATKMultiplierByCharge_Params params {};
        params.DanageInfo = DanageInfo;
        params.ATKMultiplierByCharge = ATKMultiplierByCharge;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        if (Param != nullptr)
            *Param = params.Param;
    }

    /**
     * Function:
     *         RVA    -> 0x03A3F420
     *         Name   -> Function /Game/Blueprints/Gameplay/Common/Calculation/Damage/CalcDamageBase.CalcDamageBase_C.ApplyATKMultiplierByDistance
     *         Flags  -> (Protected, HasOutParms, HasDefaults, BlueprintCallable, BlueprintEvent, Const)
     * Parameters:
     *         M1::FM1AbilityOpCalcParam                          Param                                                      (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, NoDestructor)
     *         M1::FM1CalcDamageInfo                              DamageInfo                                                 (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, ContainsInstancedReference)
     *         M1Data::FM1ScaledInteger                           ATKMultiplierByDistance                                    (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, HasGetValueTypeHash)
     *         void                                               ReturnValue
     */
    void UCalcDamageBase_C::ApplyATKMultiplierByDistance(M1::FM1AbilityOpCalcParam* Param, const M1::FM1CalcDamageInfo& DamageInfo, const M1Data::FM1ScaledInteger& ATKMultiplierByDistance)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Game/Blueprints/Gameplay/Common/Calculation/Damage/CalcDamageBase.CalcDamageBase_C.ApplyATKMultiplierByDistance");
        
        UCalcDamageBase_C_ApplyATKMultiplierByDistance_Params params {};
        params.DamageInfo = DamageInfo;
        params.ATKMultiplierByDistance = ATKMultiplierByDistance;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        if (Param != nullptr)
            *Param = params.Param;
    }

    /**
     * Function:
     *         RVA    -> 0x03A3F420
     *         Name   -> Function /Game/Blueprints/Gameplay/Common/Calculation/Damage/CalcDamageBase.CalcDamageBase_C.DetermineCritical
     *         Flags  -> (Protected, HasOutParms, HasDefaults, BlueprintCallable, BlueprintEvent, Const)
     * Parameters:
     *         M1::FM1AbilityOpCalcParam                          Param                                                      (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, NoDestructor)
     *         M1::FM1CalcDamageInfo                              DanageInfo                                                 (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, ContainsInstancedReference)
     *         void                                               ReturnValue
     */
    void UCalcDamageBase_C::DetermineCritical(M1::FM1AbilityOpCalcParam* Param, const M1::FM1CalcDamageInfo& DanageInfo)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Game/Blueprints/Gameplay/Common/Calculation/Damage/CalcDamageBase.CalcDamageBase_C.DetermineCritical");
        
        UCalcDamageBase_C_DetermineCritical_Params params {};
        params.DanageInfo = DanageInfo;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        if (Param != nullptr)
            *Param = params.Param;
    }

    /**
     * Function:
     *         RVA    -> 0x03A3F420
     *         Name   -> Function /Game/Blueprints/Gameplay/Common/Calculation/Damage/CalcDamageBase.CalcDamageBase_C.DetermineATKMultiplierByDistance
     *         Flags  -> (Protected, HasOutParms, HasDefaults, BlueprintCallable, BlueprintEvent, Const)
     * Parameters:
     *         M1::FM1AbilityOpCalcParam                          Param                                                      (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, NoDestructor)
     *         M1Data::FM1ScaledInteger                           RetATKMultiplierByDistance                                 (Parm, OutParm, NoDestructor, HasGetValueTypeHash)
     *         void                                               ReturnValue
     */
    void UCalcDamageBase_C::DetermineATKMultiplierByDistance(const M1::FM1AbilityOpCalcParam& Param, M1Data::FM1ScaledInteger* RetATKMultiplierByDistance)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Game/Blueprints/Gameplay/Common/Calculation/Damage/CalcDamageBase.CalcDamageBase_C.DetermineATKMultiplierByDistance");
        
        UCalcDamageBase_C_DetermineATKMultiplierByDistance_Params params {};
        params.Param = Param;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        if (RetATKMultiplierByDistance != nullptr)
            *RetATKMultiplierByDistance = params.RetATKMultiplierByDistance;
    }

    /**
     * Function:
     *         RVA    -> 0x03A3F420
     *         Name   -> Function /Game/Blueprints/Gameplay/Common/Calculation/Damage/CalcDamageBase.CalcDamageBase_C.ApplyATK
     *         Flags  -> (Protected, HasOutParms, HasDefaults, BlueprintCallable, BlueprintEvent, Const)
     * Parameters:
     *         M1::FM1AbilityOpCalcParam                          Param                                                      (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, NoDestructor)
     *         M1::FM1CalcDamageInfo                              DamageInfo                                                 (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, ContainsInstancedReference)
     *         BasicTypes::FName                                  ATKType                                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
     *         void                                               ReturnValue
     */
    void UCalcDamageBase_C::ApplyATK(M1::FM1AbilityOpCalcParam* Param, const M1::FM1CalcDamageInfo& DamageInfo, const BasicTypes::FName& ATKType)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Game/Blueprints/Gameplay/Common/Calculation/Damage/CalcDamageBase.CalcDamageBase_C.ApplyATK");
        
        UCalcDamageBase_C_ApplyATK_Params params {};
        params.DamageInfo = DamageInfo;
        params.ATKType = ATKType;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        if (Param != nullptr)
            *Param = params.Param;
    }

    /**
     * Function:
     *         RVA    -> 0x03A3F420
     *         Name   -> Function /Game/Blueprints/Gameplay/Common/Calculation/Damage/CalcDamageBase.CalcDamageBase_C.DoCalculation
     *         Flags  -> (Protected, HasOutParms, BlueprintCallable, BlueprintEvent, Const)
     * Parameters:
     *         M1::FM1AbilityOpCalcParam                          Param                                                      (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, NoDestructor)
     *         M1::FM1CalcDamageInfo                              DamageInfo                                                 (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, ContainsInstancedReference)
     *         void                                               ReturnValue
     */
    void UCalcDamageBase_C::DoCalculation(M1::FM1AbilityOpCalcParam* Param, M1::FM1CalcDamageInfo* DamageInfo)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Game/Blueprints/Gameplay/Common/Calculation/Damage/CalcDamageBase.CalcDamageBase_C.DoCalculation");
        
        UCalcDamageBase_C_DoCalculation_Params params {};
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        if (Param != nullptr)
            *Param = params.Param;
        if (DamageInfo != nullptr)
            *DamageInfo = params.DamageInfo;
    }

    /**
     * Function:
     *         RVA    -> 0x03A3F420
     *         Name   -> Function /Game/Blueprints/Gameplay/Common/Calculation/Damage/CalcDamageBase.CalcDamageBase_C.SetAdditionalDamageInfo
     *         Flags  -> (Protected, HasOutParms, HasDefaults, BlueprintCallable, BlueprintEvent, Const)
     * Parameters:
     *         M1::FM1AbilityOpCalcParam                          Param                                                      (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, NoDestructor)
     *         M1::FM1CalcDamageInfo                              DamageInfo                                                 (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, ContainsInstancedReference)
     *         void                                               ReturnValue
     */
    void UCalcDamageBase_C::SetAdditionalDamageInfo(M1::FM1AbilityOpCalcParam* Param, M1::FM1CalcDamageInfo* DamageInfo)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Game/Blueprints/Gameplay/Common/Calculation/Damage/CalcDamageBase.CalcDamageBase_C.SetAdditionalDamageInfo");
        
        UCalcDamageBase_C_SetAdditionalDamageInfo_Params params {};
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        if (Param != nullptr)
            *Param = params.Param;
        if (DamageInfo != nullptr)
            *DamageInfo = params.DamageInfo;
    }

    /**
     * Function:
     *         RVA    -> 0x03A3F420
     *         Name   -> Function /Game/Blueprints/Gameplay/Common/Calculation/Damage/CalcDamageBase.CalcDamageBase_C.Execute
     *         Flags  -> (Event, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintEvent, Const)
     * Parameters:
     *         M1::FM1AbilityOpCalcParam                          Param                                                      (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, NoDestructor)
     *         M1::FM1AbilityOpExecCalcOutput                     Output                                                     (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
     *         void                                               ReturnValue
     */
    void UCalcDamageBase_C::Execute(const M1::FM1AbilityOpCalcParam& Param, M1::FM1AbilityOpExecCalcOutput* Output)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Game/Blueprints/Gameplay/Common/Calculation/Damage/CalcDamageBase.CalcDamageBase_C.Execute");
        
        UCalcDamageBase_C_Execute_Params params {};
        params.Param = Param;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        if (Output != nullptr)
            *Output = params.Output;
    }

}

#ifdef _MSC_VER
    #pragma pack(pop)
#endif
