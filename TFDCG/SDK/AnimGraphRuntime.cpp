/**
 * ----------------------------------------
 * |        Generated By CheatGear        |
 * ----------------------------------------
 * | Game:    TFDCG                       |
 * | Version: 1                           |
 * | Date:    08/22/2024                  |
 * ----------------------------------------
 */

#include "pch.h"
#include <cstdint>
#include <vector>
#include <string>
#include <locale>
#include <unordered_set>
#include "Headers/Global_DEFINES.h"
#include "Headers/BasicTypes.h"
#include "Headers/CoreUObject_UFunction.h"
#include "Headers/AnimGraphRuntime_ENUMS.h"
#include "Headers/AnimGraphRuntime_PARAMS.h"
#include "Headers/AnimGraphRuntime_UBlendSpaceLibrary.h"
#include "Headers/AnimGraphRuntime_UAnimationStateMachineLibrary.h"
#include "Headers/AnimGraphRuntime_UAnimExecutionContextLibrary.h"
#include "Headers/AnimGraphRuntime_UAnimNotify_PlayMontageNotify.h"
#include "Headers/AnimGraphRuntime_UAnimNotify_PlayMontageNotifyWindow.h"
#include "Headers/AnimGraphRuntime_UAnimSequencerInstance.h"
#include "Headers/AnimGraphRuntime_UBlendSpacePlayerLibrary.h"
#include "Headers/AnimGraphRuntime_UKismetAnimationLibrary.h"
#include "Headers/AnimGraphRuntime_ULayeredBoneBlendLibrary.h"
#include "Headers/AnimGraphRuntime_ULinkedAnimGraphLibrary.h"
#include "Headers/AnimGraphRuntime_UPlayMontageCallbackProxy.h"
#include "Headers/AnimGraphRuntime_USequenceEvaluatorLibrary.h"
#include "Headers/AnimGraphRuntime_USequencePlayerLibrary.h"
#include "Headers/AnimGraphRuntime_ISequencerAnimationSupport.h"
#include "Headers/AnimGraphRuntime_USkeletalControlLibrary.h"

#ifdef _MSC_VER
    #pragma pack(push, 0x01)
#endif

namespace CG::AnimGraphRuntime
{
    // --------------------------------------------------
    // # Structs functions
    // --------------------------------------------------
    /**
     * Function:
     *         RVA    -> 0x05031BA0
     *         Name   -> Function /Script/AnimGraphRuntime.BlendSpaceLibrary.SnapToPosition
     *         Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
     * Parameters:
     *         AnimGraphRuntime::FBlendSpaceReference             BlendSpace                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
     *         CoreUObject::FVector                               NewPosition                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         void                                               ReturnValue
     */
    void UBlendSpaceLibrary::STATIC_SnapToPosition(const AnimGraphRuntime::FBlendSpaceReference& BlendSpace, const CoreUObject::FVector& NewPosition)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/AnimGraphRuntime.BlendSpaceLibrary.SnapToPosition");
        
        UBlendSpaceLibrary_SnapToPosition_Params params {};
        params.BlendSpace = BlendSpace;
        params.NewPosition = NewPosition;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
    }

    /**
     * Function:
     *         RVA    -> 0x05031F00
     *         Name   -> Function /Script/AnimGraphRuntime.BlendSpaceLibrary.GetPosition
     *         Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
     * Parameters:
     *         AnimGraphRuntime::FBlendSpaceReference             BlendSpace                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
     *         CoreUObject::FVector                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     */
    CoreUObject::FVector UBlendSpaceLibrary::STATIC_GetPosition(const AnimGraphRuntime::FBlendSpaceReference& BlendSpace)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/AnimGraphRuntime.BlendSpaceLibrary.GetPosition");
        
        UBlendSpaceLibrary_GetPosition_Params params {};
        params.BlendSpace = BlendSpace;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        return params.ReturnValue;
    }

    /**
     * Function:
     *         RVA    -> 0x05031D90
     *         Name   -> Function /Script/AnimGraphRuntime.BlendSpaceLibrary.GetFilteredPosition
     *         Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
     * Parameters:
     *         AnimGraphRuntime::FBlendSpaceReference             BlendSpace                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
     *         CoreUObject::FVector                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     */
    CoreUObject::FVector UBlendSpaceLibrary::STATIC_GetFilteredPosition(const AnimGraphRuntime::FBlendSpaceReference& BlendSpace)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/AnimGraphRuntime.BlendSpaceLibrary.GetFilteredPosition");
        
        UBlendSpaceLibrary_GetFilteredPosition_Params params {};
        params.BlendSpace = BlendSpace;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        return params.ReturnValue;
    }

    /**
     * Function:
     *         RVA    -> 0x05032070
     *         Name   -> Function /Script/AnimGraphRuntime.BlendSpaceLibrary.ConvertToBlendSpacePure
     *         Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
     * Parameters:
     *         Engine::FAnimNodeReference                         Node                                                       (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
     *         AnimGraphRuntime::FBlendSpaceReference             BlendSpace                                                 (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
     *         bool                                               Result                                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         void                                               ReturnValue
     */
    void UBlendSpaceLibrary::STATIC_ConvertToBlendSpacePure(const Engine::FAnimNodeReference& Node, AnimGraphRuntime::FBlendSpaceReference* BlendSpace, bool* Result)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/AnimGraphRuntime.BlendSpaceLibrary.ConvertToBlendSpacePure");
        
        UBlendSpaceLibrary_ConvertToBlendSpacePure_Params params {};
        params.Node = Node;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        if (BlendSpace != nullptr)
            *BlendSpace = params.BlendSpace;
        if (Result != nullptr)
            *Result = params.Result;
    }

    /**
     * Function:
     *         RVA    -> 0x050322F0
     *         Name   -> Function /Script/AnimGraphRuntime.BlendSpaceLibrary.ConvertToBlendSpace
     *         Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
     * Parameters:
     *         Engine::FAnimNodeReference                         Node                                                       (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
     *         Engine::EAnimNodeReferenceConversionResult         Result                                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         AnimGraphRuntime::FBlendSpaceReference             ReturnValue                                                (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
     */
    AnimGraphRuntime::FBlendSpaceReference UBlendSpaceLibrary::STATIC_ConvertToBlendSpace(const Engine::FAnimNodeReference& Node, Engine::EAnimNodeReferenceConversionResult* Result)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/AnimGraphRuntime.BlendSpaceLibrary.ConvertToBlendSpace");
        
        UBlendSpaceLibrary_ConvertToBlendSpace_Params params {};
        params.Node = Node;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        if (Result != nullptr)
            *Result = params.Result;
        
        return params.ReturnValue;
    }

    /**
     * Function:
     *         RVA    -> 0x05033690
     *         Name   -> Function /Script/AnimGraphRuntime.AnimationStateMachineLibrary.SetState
     *         Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
     * Parameters:
     *         Engine::FAnimUpdateContext                         UpdateContext                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
     *         AnimGraphRuntime::FAnimationStateMachineReference  Node                                                       (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
     *         BasicTypes::FName                                  TargetState                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         float                                              Duration                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         Engine::ETransitionLogicType                       BlendType                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         Engine::UBlendProfile*                             BlendProfile                                               (Parm, ZeroConstructor, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         Engine::EAlphaBlendOption                          AlphaBlendOption                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         Engine::UCurveFloat*                               CustomBlendCurve                                           (Parm, ZeroConstructor, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         void                                               ReturnValue
     */
    void UAnimationStateMachineLibrary::STATIC_SetState(const Engine::FAnimUpdateContext& UpdateContext, const AnimGraphRuntime::FAnimationStateMachineReference& Node, const BasicTypes::FName& TargetState, float Duration, Engine::ETransitionLogicType BlendType, Engine::UBlendProfile* BlendProfile, Engine::EAlphaBlendOption AlphaBlendOption, Engine::UCurveFloat* CustomBlendCurve)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/AnimGraphRuntime.AnimationStateMachineLibrary.SetState");
        
        UAnimationStateMachineLibrary_SetState_Params params {};
        params.UpdateContext = UpdateContext;
        params.Node = Node;
        params.TargetState = TargetState;
        params.Duration = Duration;
        params.BlendType = BlendType;
        params.BlendProfile = BlendProfile;
        params.AlphaBlendOption = AlphaBlendOption;
        params.CustomBlendCurve = CustomBlendCurve;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
    }

    /**
     * Function:
     *         RVA    -> 0x05033C00
     *         Name   -> Function /Script/AnimGraphRuntime.AnimationStateMachineLibrary.IsStateBlendingOut
     *         Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
     * Parameters:
     *         Engine::FAnimUpdateContext                         UpdateContext                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
     *         AnimGraphRuntime::FAnimationStateResultReference   Node                                                       (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
     *         bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     */
    bool UAnimationStateMachineLibrary::STATIC_IsStateBlendingOut(const Engine::FAnimUpdateContext& UpdateContext, const AnimGraphRuntime::FAnimationStateResultReference& Node)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/AnimGraphRuntime.AnimationStateMachineLibrary.IsStateBlendingOut");
        
        UAnimationStateMachineLibrary_IsStateBlendingOut_Params params {};
        params.UpdateContext = UpdateContext;
        params.Node = Node;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        return params.ReturnValue;
    }

    /**
     * Function:
     *         RVA    -> 0x05033E30
     *         Name   -> Function /Script/AnimGraphRuntime.AnimationStateMachineLibrary.IsStateBlendingIn
     *         Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
     * Parameters:
     *         Engine::FAnimUpdateContext                         UpdateContext                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
     *         AnimGraphRuntime::FAnimationStateResultReference   Node                                                       (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
     *         bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     */
    bool UAnimationStateMachineLibrary::STATIC_IsStateBlendingIn(const Engine::FAnimUpdateContext& UpdateContext, const AnimGraphRuntime::FAnimationStateResultReference& Node)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/AnimGraphRuntime.AnimationStateMachineLibrary.IsStateBlendingIn");
        
        UAnimationStateMachineLibrary_IsStateBlendingIn_Params params {};
        params.UpdateContext = UpdateContext;
        params.Node = Node;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        return params.ReturnValue;
    }

    /**
     * Function:
     *         RVA    -> 0x05033450
     *         Name   -> Function /Script/AnimGraphRuntime.AnimationStateMachineLibrary.GetState
     *         Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
     * Parameters:
     *         Engine::FAnimUpdateContext                         UpdateContext                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
     *         AnimGraphRuntime::FAnimationStateMachineReference  Node                                                       (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
     *         BasicTypes::FName                                  ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     */
    BasicTypes::FName UAnimationStateMachineLibrary::STATIC_GetState(const Engine::FAnimUpdateContext& UpdateContext, const AnimGraphRuntime::FAnimationStateMachineReference& Node)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/AnimGraphRuntime.AnimationStateMachineLibrary.GetState");
        
        UAnimationStateMachineLibrary_GetState_Params params {};
        params.UpdateContext = UpdateContext;
        params.Node = Node;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        return params.ReturnValue;
    }

    /**
     * Function:
     *         RVA    -> 0x05032FD0
     *         Name   -> Function /Script/AnimGraphRuntime.AnimationStateMachineLibrary.GetRelevantAnimTimeRemainingFraction
     *         Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
     * Parameters:
     *         Engine::FAnimUpdateContext                         UpdateContext                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
     *         AnimGraphRuntime::FAnimationStateResultReference   Node                                                       (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
     *         float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     */
    float UAnimationStateMachineLibrary::STATIC_GetRelevantAnimTimeRemainingFraction(const Engine::FAnimUpdateContext& UpdateContext, const AnimGraphRuntime::FAnimationStateResultReference& Node)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/AnimGraphRuntime.AnimationStateMachineLibrary.GetRelevantAnimTimeRemainingFraction");
        
        UAnimationStateMachineLibrary_GetRelevantAnimTimeRemainingFraction_Params params {};
        params.UpdateContext = UpdateContext;
        params.Node = Node;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        return params.ReturnValue;
    }

    /**
     * Function:
     *         RVA    -> 0x05033210
     *         Name   -> Function /Script/AnimGraphRuntime.AnimationStateMachineLibrary.GetRelevantAnimTimeRemaining
     *         Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
     * Parameters:
     *         Engine::FAnimUpdateContext                         UpdateContext                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
     *         AnimGraphRuntime::FAnimationStateResultReference   Node                                                       (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
     *         float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     */
    float UAnimationStateMachineLibrary::STATIC_GetRelevantAnimTimeRemaining(const Engine::FAnimUpdateContext& UpdateContext, const AnimGraphRuntime::FAnimationStateResultReference& Node)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/AnimGraphRuntime.AnimationStateMachineLibrary.GetRelevantAnimTimeRemaining");
        
        UAnimationStateMachineLibrary_GetRelevantAnimTimeRemaining_Params params {};
        params.UpdateContext = UpdateContext;
        params.Node = Node;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        return params.ReturnValue;
    }

    /**
     * Function:
     *         RVA    -> 0x05034530
     *         Name   -> Function /Script/AnimGraphRuntime.AnimationStateMachineLibrary.ConvertToAnimationStateResultPure
     *         Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
     * Parameters:
     *         Engine::FAnimNodeReference                         Node                                                       (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
     *         AnimGraphRuntime::FAnimationStateResultReference   AnimationState                                             (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
     *         bool                                               Result                                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         void                                               ReturnValue
     */
    void UAnimationStateMachineLibrary::STATIC_ConvertToAnimationStateResultPure(const Engine::FAnimNodeReference& Node, AnimGraphRuntime::FAnimationStateResultReference* AnimationState, bool* Result)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/AnimGraphRuntime.AnimationStateMachineLibrary.ConvertToAnimationStateResultPure");
        
        UAnimationStateMachineLibrary_ConvertToAnimationStateResultPure_Params params {};
        params.Node = Node;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        if (AnimationState != nullptr)
            *AnimationState = params.AnimationState;
        if (Result != nullptr)
            *Result = params.Result;
    }

    /**
     * Function:
     *         RVA    -> 0x050347C0
     *         Name   -> Function /Script/AnimGraphRuntime.AnimationStateMachineLibrary.ConvertToAnimationStateResult
     *         Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
     * Parameters:
     *         Engine::FAnimNodeReference                         Node                                                       (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
     *         AnimGraphRuntime::FAnimationStateResultReference   AnimationState                                             (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
     *         Engine::EAnimNodeReferenceConversionResult         Result                                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         void                                               ReturnValue
     */
    void UAnimationStateMachineLibrary::STATIC_ConvertToAnimationStateResult(const Engine::FAnimNodeReference& Node, AnimGraphRuntime::FAnimationStateResultReference* AnimationState, Engine::EAnimNodeReferenceConversionResult* Result)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/AnimGraphRuntime.AnimationStateMachineLibrary.ConvertToAnimationStateResult");
        
        UAnimationStateMachineLibrary_ConvertToAnimationStateResult_Params params {};
        params.Node = Node;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        if (AnimationState != nullptr)
            *AnimationState = params.AnimationState;
        if (Result != nullptr)
            *Result = params.Result;
    }

    /**
     * Function:
     *         RVA    -> 0x05034060
     *         Name   -> Function /Script/AnimGraphRuntime.AnimationStateMachineLibrary.ConvertToAnimationStateMachinePure
     *         Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
     * Parameters:
     *         Engine::FAnimNodeReference                         Node                                                       (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
     *         AnimGraphRuntime::FAnimationStateMachineReference  AnimationState                                             (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
     *         bool                                               Result                                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         void                                               ReturnValue
     */
    void UAnimationStateMachineLibrary::STATIC_ConvertToAnimationStateMachinePure(const Engine::FAnimNodeReference& Node, AnimGraphRuntime::FAnimationStateMachineReference* AnimationState, bool* Result)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/AnimGraphRuntime.AnimationStateMachineLibrary.ConvertToAnimationStateMachinePure");
        
        UAnimationStateMachineLibrary_ConvertToAnimationStateMachinePure_Params params {};
        params.Node = Node;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        if (AnimationState != nullptr)
            *AnimationState = params.AnimationState;
        if (Result != nullptr)
            *Result = params.Result;
    }

    /**
     * Function:
     *         RVA    -> 0x050342F0
     *         Name   -> Function /Script/AnimGraphRuntime.AnimationStateMachineLibrary.ConvertToAnimationStateMachine
     *         Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
     * Parameters:
     *         Engine::FAnimNodeReference                         Node                                                       (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
     *         AnimGraphRuntime::FAnimationStateMachineReference  AnimationState                                             (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
     *         Engine::EAnimNodeReferenceConversionResult         Result                                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         void                                               ReturnValue
     */
    void UAnimationStateMachineLibrary::STATIC_ConvertToAnimationStateMachine(const Engine::FAnimNodeReference& Node, AnimGraphRuntime::FAnimationStateMachineReference* AnimationState, Engine::EAnimNodeReferenceConversionResult* Result)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/AnimGraphRuntime.AnimationStateMachineLibrary.ConvertToAnimationStateMachine");
        
        UAnimationStateMachineLibrary_ConvertToAnimationStateMachine_Params params {};
        params.Node = Node;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        if (AnimationState != nullptr)
            *AnimationState = params.AnimationState;
        if (Result != nullptr)
            *Result = params.Result;
    }

    /**
     * Function:
     *         RVA    -> 0x05035900
     *         Name   -> Function /Script/AnimGraphRuntime.AnimExecutionContextLibrary.GetDeltaTime
     *         Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
     * Parameters:
     *         Engine::FAnimUpdateContext                         Context                                                    (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
     *         float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     */
    float UAnimExecutionContextLibrary::STATIC_GetDeltaTime(const Engine::FAnimUpdateContext& Context)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/AnimGraphRuntime.AnimExecutionContextLibrary.GetDeltaTime");
        
        UAnimExecutionContextLibrary_GetDeltaTime_Params params {};
        params.Context = Context;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        return params.ReturnValue;
    }

    /**
     * Function:
     *         RVA    -> 0x050357D0
     *         Name   -> Function /Script/AnimGraphRuntime.AnimExecutionContextLibrary.GetCurrentWeight
     *         Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
     * Parameters:
     *         Engine::FAnimUpdateContext                         Context                                                    (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
     *         float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     */
    float UAnimExecutionContextLibrary::STATIC_GetCurrentWeight(const Engine::FAnimUpdateContext& Context)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/AnimGraphRuntime.AnimExecutionContextLibrary.GetCurrentWeight");
        
        UAnimExecutionContextLibrary_GetCurrentWeight_Params params {};
        params.Context = Context;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        return params.ReturnValue;
    }

    /**
     * Function:
     *         RVA    -> 0x05035F70
     *         Name   -> Function /Script/AnimGraphRuntime.AnimExecutionContextLibrary.GetAnimNodeReference
     *         Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
     * Parameters:
     *         Engine::UAnimInstance*                             Instance                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         int32_t                                            Index                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         Engine::FAnimNodeReference                         ReturnValue                                                (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
     */
    Engine::FAnimNodeReference UAnimExecutionContextLibrary::STATIC_GetAnimNodeReference(Engine::UAnimInstance* Instance, int32_t Index)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/AnimGraphRuntime.AnimExecutionContextLibrary.GetAnimNodeReference");
        
        UAnimExecutionContextLibrary_GetAnimNodeReference_Params params {};
        params.Instance = Instance;
        params.Index = Index;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        return params.ReturnValue;
    }

    /**
     * Function:
     *         RVA    -> 0x05036180
     *         Name   -> Function /Script/AnimGraphRuntime.AnimExecutionContextLibrary.GetAnimInstance
     *         Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
     * Parameters:
     *         Engine::FAnimExecutionContext                      Context                                                    (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
     *         Engine::UAnimInstance*                             ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     */
    Engine::UAnimInstance* UAnimExecutionContextLibrary::STATIC_GetAnimInstance(const Engine::FAnimExecutionContext& Context)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/AnimGraphRuntime.AnimExecutionContextLibrary.GetAnimInstance");
        
        UAnimExecutionContextLibrary_GetAnimInstance_Params params {};
        params.Context = Context;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        return params.ReturnValue;
    }

    /**
     * Function:
     *         RVA    -> 0x05035A30
     *         Name   -> Function /Script/AnimGraphRuntime.AnimExecutionContextLibrary.ConvertToUpdateContext
     *         Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
     * Parameters:
     *         Engine::FAnimExecutionContext                      Context                                                    (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
     *         Engine::EAnimExecutionContextConversionResult      Result                                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         Engine::FAnimUpdateContext                         ReturnValue                                                (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
     */
    Engine::FAnimUpdateContext UAnimExecutionContextLibrary::STATIC_ConvertToUpdateContext(const Engine::FAnimExecutionContext& Context, Engine::EAnimExecutionContextConversionResult* Result)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/AnimGraphRuntime.AnimExecutionContextLibrary.ConvertToUpdateContext");
        
        UAnimExecutionContextLibrary_ConvertToUpdateContext_Params params {};
        params.Context = Context;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        if (Result != nullptr)
            *Result = params.Result;
        
        return params.ReturnValue;
    }

    /**
     * Function:
     *         RVA    -> 0x05035530
     *         Name   -> Function /Script/AnimGraphRuntime.AnimExecutionContextLibrary.ConvertToPoseContext
     *         Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
     * Parameters:
     *         Engine::FAnimExecutionContext                      Context                                                    (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
     *         Engine::EAnimExecutionContextConversionResult      Result                                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         Engine::FAnimPoseContext                           ReturnValue                                                (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
     */
    Engine::FAnimPoseContext UAnimExecutionContextLibrary::STATIC_ConvertToPoseContext(const Engine::FAnimExecutionContext& Context, Engine::EAnimExecutionContextConversionResult* Result)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/AnimGraphRuntime.AnimExecutionContextLibrary.ConvertToPoseContext");
        
        UAnimExecutionContextLibrary_ConvertToPoseContext_Params params {};
        params.Context = Context;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        if (Result != nullptr)
            *Result = params.Result;
        
        return params.ReturnValue;
    }

    /**
     * Function:
     *         RVA    -> 0x05035CD0
     *         Name   -> Function /Script/AnimGraphRuntime.AnimExecutionContextLibrary.ConvertToInitializationContext
     *         Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
     * Parameters:
     *         Engine::FAnimExecutionContext                      Context                                                    (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
     *         Engine::EAnimExecutionContextConversionResult      Result                                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         Engine::FAnimInitializationContext                 ReturnValue                                                (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
     */
    Engine::FAnimInitializationContext UAnimExecutionContextLibrary::STATIC_ConvertToInitializationContext(const Engine::FAnimExecutionContext& Context, Engine::EAnimExecutionContextConversionResult* Result)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/AnimGraphRuntime.AnimExecutionContextLibrary.ConvertToInitializationContext");
        
        UAnimExecutionContextLibrary_ConvertToInitializationContext_Params params {};
        params.Context = Context;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        if (Result != nullptr)
            *Result = params.Result;
        
        return params.ReturnValue;
    }

    /**
     * Function:
     *         RVA    -> 0x05035290
     *         Name   -> Function /Script/AnimGraphRuntime.AnimExecutionContextLibrary.ConvertToComponentSpacePoseContext
     *         Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
     * Parameters:
     *         Engine::FAnimExecutionContext                      Context                                                    (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
     *         Engine::EAnimExecutionContextConversionResult      Result                                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         Engine::FAnimComponentSpacePoseContext             ReturnValue                                                (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
     */
    Engine::FAnimComponentSpacePoseContext UAnimExecutionContextLibrary::STATIC_ConvertToComponentSpacePoseContext(const Engine::FAnimExecutionContext& Context, Engine::EAnimExecutionContextConversionResult* Result)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/AnimGraphRuntime.AnimExecutionContextLibrary.ConvertToComponentSpacePoseContext");
        
        UAnimExecutionContextLibrary_ConvertToComponentSpacePoseContext_Params params {};
        params.Context = Context;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        if (Result != nullptr)
            *Result = params.Result;
        
        return params.ReturnValue;
    }

    /**
     * Function:
     *         RVA    -> 0x05057E60
     *         Name   -> Function /Script/AnimGraphRuntime.BlendSpacePlayerLibrary.SnapToPosition
     *         Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
     * Parameters:
     *         AnimGraphRuntime::FBlendSpacePlayerReference       BlendSpacePlayer                                           (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
     *         CoreUObject::FVector                               NewPosition                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         void                                               ReturnValue
     */
    void UBlendSpacePlayerLibrary::STATIC_SnapToPosition(const AnimGraphRuntime::FBlendSpacePlayerReference& BlendSpacePlayer, const CoreUObject::FVector& NewPosition)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/AnimGraphRuntime.BlendSpacePlayerLibrary.SnapToPosition");
        
        UBlendSpacePlayerLibrary_SnapToPosition_Params params {};
        params.BlendSpacePlayer = BlendSpacePlayer;
        params.NewPosition = NewPosition;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
    }

    /**
     * Function:
     *         RVA    -> 0x05058050
     *         Name   -> Function /Script/AnimGraphRuntime.BlendSpacePlayerLibrary.ShouldResetPlayTimeWhenBlendSpaceChanges
     *         Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
     * Parameters:
     *         AnimGraphRuntime::FBlendSpacePlayerReference       BlendSpacePlayer                                           (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
     *         bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     */
    bool UBlendSpacePlayerLibrary::STATIC_ShouldResetPlayTimeWhenBlendSpaceChanges(const AnimGraphRuntime::FBlendSpacePlayerReference& BlendSpacePlayer)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/AnimGraphRuntime.BlendSpacePlayerLibrary.ShouldResetPlayTimeWhenBlendSpaceChanges");
        
        UBlendSpacePlayerLibrary_ShouldResetPlayTimeWhenBlendSpaceChanges_Params params {};
        params.BlendSpacePlayer = BlendSpacePlayer;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        return params.ReturnValue;
    }

    /**
     * Function:
     *         RVA    -> 0x05058C60
     *         Name   -> Function /Script/AnimGraphRuntime.BlendSpacePlayerLibrary.SetResetPlayTimeWhenBlendSpaceChanges
     *         Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
     * Parameters:
     *         AnimGraphRuntime::FBlendSpacePlayerReference       BlendSpacePlayer                                           (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
     *         bool                                               bReset                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         AnimGraphRuntime::FBlendSpacePlayerReference       ReturnValue                                                (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
     */
    AnimGraphRuntime::FBlendSpacePlayerReference UBlendSpacePlayerLibrary::STATIC_SetResetPlayTimeWhenBlendSpaceChanges(const AnimGraphRuntime::FBlendSpacePlayerReference& BlendSpacePlayer, bool bReset)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/AnimGraphRuntime.BlendSpacePlayerLibrary.SetResetPlayTimeWhenBlendSpaceChanges");
        
        UBlendSpacePlayerLibrary_SetResetPlayTimeWhenBlendSpaceChanges_Params params {};
        params.BlendSpacePlayer = BlendSpacePlayer;
        params.bReset = bReset;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        return params.ReturnValue;
    }

    /**
     * Function:
     *         RVA    -> 0x05058A70
     *         Name   -> Function /Script/AnimGraphRuntime.BlendSpacePlayerLibrary.SetPlayRate
     *         Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
     * Parameters:
     *         AnimGraphRuntime::FBlendSpacePlayerReference       BlendSpacePlayer                                           (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
     *         float                                              PlayRate                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         AnimGraphRuntime::FBlendSpacePlayerReference       ReturnValue                                                (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
     */
    AnimGraphRuntime::FBlendSpacePlayerReference UBlendSpacePlayerLibrary::STATIC_SetPlayRate(const AnimGraphRuntime::FBlendSpacePlayerReference& BlendSpacePlayer, float PlayRate)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/AnimGraphRuntime.BlendSpacePlayerLibrary.SetPlayRate");
        
        UBlendSpacePlayerLibrary_SetPlayRate_Params params {};
        params.BlendSpacePlayer = BlendSpacePlayer;
        params.PlayRate = PlayRate;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        return params.ReturnValue;
    }

    /**
     * Function:
     *         RVA    -> 0x05058890
     *         Name   -> Function /Script/AnimGraphRuntime.BlendSpacePlayerLibrary.SetLoop
     *         Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
     * Parameters:
     *         AnimGraphRuntime::FBlendSpacePlayerReference       BlendSpacePlayer                                           (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
     *         bool                                               bLoop                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         AnimGraphRuntime::FBlendSpacePlayerReference       ReturnValue                                                (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
     */
    AnimGraphRuntime::FBlendSpacePlayerReference UBlendSpacePlayerLibrary::STATIC_SetLoop(const AnimGraphRuntime::FBlendSpacePlayerReference& BlendSpacePlayer, bool bLoop)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/AnimGraphRuntime.BlendSpacePlayerLibrary.SetLoop");
        
        UBlendSpacePlayerLibrary_SetLoop_Params params {};
        params.BlendSpacePlayer = BlendSpacePlayer;
        params.bLoop = bLoop;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        return params.ReturnValue;
    }

    /**
     * Function:
     *         RVA    -> 0x05058E40
     *         Name   -> Function /Script/AnimGraphRuntime.BlendSpacePlayerLibrary.SetBlendSpaceWithInertialBlending
     *         Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
     * Parameters:
     *         Engine::FAnimUpdateContext                         UpdateContext                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
     *         AnimGraphRuntime::FBlendSpacePlayerReference       BlendSpacePlayer                                           (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
     *         Engine::UBlendSpace*                               BlendSpace                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         float                                              BlendTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         AnimGraphRuntime::FBlendSpacePlayerReference       ReturnValue                                                (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
     */
    AnimGraphRuntime::FBlendSpacePlayerReference UBlendSpacePlayerLibrary::STATIC_SetBlendSpaceWithInertialBlending(const Engine::FAnimUpdateContext& UpdateContext, const AnimGraphRuntime::FBlendSpacePlayerReference& BlendSpacePlayer, Engine::UBlendSpace* BlendSpace, float BlendTime)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/AnimGraphRuntime.BlendSpacePlayerLibrary.SetBlendSpaceWithInertialBlending");
        
        UBlendSpacePlayerLibrary_SetBlendSpaceWithInertialBlending_Params params {};
        params.UpdateContext = UpdateContext;
        params.BlendSpacePlayer = BlendSpacePlayer;
        params.BlendSpace = BlendSpace;
        params.BlendTime = BlendTime;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        return params.ReturnValue;
    }

    /**
     * Function:
     *         RVA    -> 0x050591A0
     *         Name   -> Function /Script/AnimGraphRuntime.BlendSpacePlayerLibrary.SetBlendSpace
     *         Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
     * Parameters:
     *         AnimGraphRuntime::FBlendSpacePlayerReference       BlendSpacePlayer                                           (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
     *         Engine::UBlendSpace*                               BlendSpace                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         AnimGraphRuntime::FBlendSpacePlayerReference       ReturnValue                                                (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
     */
    AnimGraphRuntime::FBlendSpacePlayerReference UBlendSpacePlayerLibrary::STATIC_SetBlendSpace(const AnimGraphRuntime::FBlendSpacePlayerReference& BlendSpacePlayer, Engine::UBlendSpace* BlendSpace)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/AnimGraphRuntime.BlendSpacePlayerLibrary.SetBlendSpace");
        
        UBlendSpacePlayerLibrary_SetBlendSpace_Params params {};
        params.BlendSpacePlayer = BlendSpacePlayer;
        params.BlendSpace = BlendSpace;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        return params.ReturnValue;
    }

    /**
     * Function:
     *         RVA    -> 0x05058450
     *         Name   -> Function /Script/AnimGraphRuntime.BlendSpacePlayerLibrary.GetStartPosition
     *         Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
     * Parameters:
     *         AnimGraphRuntime::FBlendSpacePlayerReference       BlendSpacePlayer                                           (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
     *         float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     */
    float UBlendSpacePlayerLibrary::STATIC_GetStartPosition(const AnimGraphRuntime::FBlendSpacePlayerReference& BlendSpacePlayer)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/AnimGraphRuntime.BlendSpacePlayerLibrary.GetStartPosition");
        
        UBlendSpacePlayerLibrary_GetStartPosition_Params params {};
        params.BlendSpacePlayer = BlendSpacePlayer;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        return params.ReturnValue;
    }

    /**
     * Function:
     *         RVA    -> 0x050585B0
     *         Name   -> Function /Script/AnimGraphRuntime.BlendSpacePlayerLibrary.GetPosition
     *         Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
     * Parameters:
     *         AnimGraphRuntime::FBlendSpacePlayerReference       BlendSpacePlayer                                           (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
     *         CoreUObject::FVector                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     */
    CoreUObject::FVector UBlendSpacePlayerLibrary::STATIC_GetPosition(const AnimGraphRuntime::FBlendSpacePlayerReference& BlendSpacePlayer)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/AnimGraphRuntime.BlendSpacePlayerLibrary.GetPosition");
        
        UBlendSpacePlayerLibrary_GetPosition_Params params {};
        params.BlendSpacePlayer = BlendSpacePlayer;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        return params.ReturnValue;
    }

    /**
     * Function:
     *         RVA    -> 0x050582F0
     *         Name   -> Function /Script/AnimGraphRuntime.BlendSpacePlayerLibrary.GetPlayRate
     *         Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
     * Parameters:
     *         AnimGraphRuntime::FBlendSpacePlayerReference       BlendSpacePlayer                                           (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
     *         float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     */
    float UBlendSpacePlayerLibrary::STATIC_GetPlayRate(const AnimGraphRuntime::FBlendSpacePlayerReference& BlendSpacePlayer)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/AnimGraphRuntime.BlendSpacePlayerLibrary.GetPlayRate");
        
        UBlendSpacePlayerLibrary_GetPlayRate_Params params {};
        params.BlendSpacePlayer = BlendSpacePlayer;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        return params.ReturnValue;
    }

    /**
     * Function:
     *         RVA    -> 0x050581A0
     *         Name   -> Function /Script/AnimGraphRuntime.BlendSpacePlayerLibrary.GetLoop
     *         Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
     * Parameters:
     *         AnimGraphRuntime::FBlendSpacePlayerReference       BlendSpacePlayer                                           (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
     *         bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     */
    bool UBlendSpacePlayerLibrary::STATIC_GetLoop(const AnimGraphRuntime::FBlendSpacePlayerReference& BlendSpacePlayer)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/AnimGraphRuntime.BlendSpacePlayerLibrary.GetLoop");
        
        UBlendSpacePlayerLibrary_GetLoop_Params params {};
        params.BlendSpacePlayer = BlendSpacePlayer;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        return params.ReturnValue;
    }

    /**
     * Function:
     *         RVA    -> 0x05058730
     *         Name   -> Function /Script/AnimGraphRuntime.BlendSpacePlayerLibrary.GetBlendSpace
     *         Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
     * Parameters:
     *         AnimGraphRuntime::FBlendSpacePlayerReference       BlendSpacePlayer                                           (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
     *         Engine::UBlendSpace*                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     */
    Engine::UBlendSpace* UBlendSpacePlayerLibrary::STATIC_GetBlendSpace(const AnimGraphRuntime::FBlendSpacePlayerReference& BlendSpacePlayer)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/AnimGraphRuntime.BlendSpacePlayerLibrary.GetBlendSpace");
        
        UBlendSpacePlayerLibrary_GetBlendSpace_Params params {};
        params.BlendSpacePlayer = BlendSpacePlayer;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        return params.ReturnValue;
    }

    /**
     * Function:
     *         RVA    -> 0x05059380
     *         Name   -> Function /Script/AnimGraphRuntime.BlendSpacePlayerLibrary.ConvertToBlendSpacePlayerPure
     *         Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
     * Parameters:
     *         Engine::FAnimNodeReference                         Node                                                       (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
     *         AnimGraphRuntime::FBlendSpacePlayerReference       BlendSpacePlayer                                           (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
     *         bool                                               Result                                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         void                                               ReturnValue
     */
    void UBlendSpacePlayerLibrary::STATIC_ConvertToBlendSpacePlayerPure(const Engine::FAnimNodeReference& Node, AnimGraphRuntime::FBlendSpacePlayerReference* BlendSpacePlayer, bool* Result)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/AnimGraphRuntime.BlendSpacePlayerLibrary.ConvertToBlendSpacePlayerPure");
        
        UBlendSpacePlayerLibrary_ConvertToBlendSpacePlayerPure_Params params {};
        params.Node = Node;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        if (BlendSpacePlayer != nullptr)
            *BlendSpacePlayer = params.BlendSpacePlayer;
        if (Result != nullptr)
            *Result = params.Result;
    }

    /**
     * Function:
     *         RVA    -> 0x05059600
     *         Name   -> Function /Script/AnimGraphRuntime.BlendSpacePlayerLibrary.ConvertToBlendSpacePlayer
     *         Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
     * Parameters:
     *         Engine::FAnimNodeReference                         Node                                                       (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
     *         Engine::EAnimNodeReferenceConversionResult         Result                                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         AnimGraphRuntime::FBlendSpacePlayerReference       ReturnValue                                                (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
     */
    AnimGraphRuntime::FBlendSpacePlayerReference UBlendSpacePlayerLibrary::STATIC_ConvertToBlendSpacePlayer(const Engine::FAnimNodeReference& Node, Engine::EAnimNodeReferenceConversionResult* Result)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/AnimGraphRuntime.BlendSpacePlayerLibrary.ConvertToBlendSpacePlayer");
        
        UBlendSpacePlayerLibrary_ConvertToBlendSpacePlayer_Params params {};
        params.Node = Node;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        if (Result != nullptr)
            *Result = params.Result;
        
        return params.ReturnValue;
    }

    /**
     * Function:
     *         RVA    -> 0x0508E670
     *         Name   -> Function /Script/AnimGraphRuntime.KismetAnimationLibrary.K2_TwoBoneIK
     *         Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
     * Parameters:
     *         CoreUObject::FVector                               RootPos                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         CoreUObject::FVector                               JointPos                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         CoreUObject::FVector                               EndPos                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         CoreUObject::FVector                               JointTarget                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         CoreUObject::FVector                               Effector                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         CoreUObject::FVector                               OutJointPos                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         CoreUObject::FVector                               OutEndPos                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         bool                                               bAllowStretching                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         float                                              StartStretchRatio                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         float                                              MaxStretchScale                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         void                                               ReturnValue
     */
    void UKismetAnimationLibrary::STATIC_K2_TwoBoneIK(const CoreUObject::FVector& RootPos, const CoreUObject::FVector& JointPos, const CoreUObject::FVector& EndPos, const CoreUObject::FVector& JointTarget, const CoreUObject::FVector& Effector, CoreUObject::FVector* OutJointPos, CoreUObject::FVector* OutEndPos, bool bAllowStretching, float StartStretchRatio, float MaxStretchScale)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/AnimGraphRuntime.KismetAnimationLibrary.K2_TwoBoneIK");
        
        UKismetAnimationLibrary_K2_TwoBoneIK_Params params {};
        params.RootPos = RootPos;
        params.JointPos = JointPos;
        params.EndPos = EndPos;
        params.JointTarget = JointTarget;
        params.Effector = Effector;
        params.bAllowStretching = bAllowStretching;
        params.StartStretchRatio = StartStretchRatio;
        params.MaxStretchScale = MaxStretchScale;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        if (OutJointPos != nullptr)
            *OutJointPos = params.OutJointPos;
        if (OutEndPos != nullptr)
            *OutEndPos = params.OutEndPos;
    }

    /**
     * Function:
     *         RVA    -> 0x0508C0B0
     *         Name   -> Function /Script/AnimGraphRuntime.KismetAnimationLibrary.K2_StartProfilingTimer
     *         Flags  -> (Final, Native, Static, Public, BlueprintCallable)
     * Parameters:
     *         void                                               ReturnValue
     */
    void UKismetAnimationLibrary::STATIC_K2_StartProfilingTimer()
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/AnimGraphRuntime.KismetAnimationLibrary.K2_StartProfilingTimer");
        
        UKismetAnimationLibrary_K2_StartProfilingTimer_Params params {};
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
    }

    /**
     * Function:
     *         RVA    -> 0x0508D110
     *         Name   -> Function /Script/AnimGraphRuntime.KismetAnimationLibrary.K2_MakePerlinNoiseVectorAndRemap
     *         Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
     * Parameters:
     *         float                                              X                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         float                                              Y                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         float                                              Z                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         float                                              RangeOutMinX                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         float                                              RangeOutMaxX                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         float                                              RangeOutMinY                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         float                                              RangeOutMaxY                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         float                                              RangeOutMinZ                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         float                                              RangeOutMaxZ                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         CoreUObject::FVector                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     */
    CoreUObject::FVector UKismetAnimationLibrary::STATIC_K2_MakePerlinNoiseVectorAndRemap(float X, float Y, float Z, float RangeOutMinX, float RangeOutMaxX, float RangeOutMinY, float RangeOutMaxY, float RangeOutMinZ, float RangeOutMaxZ)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/AnimGraphRuntime.KismetAnimationLibrary.K2_MakePerlinNoiseVectorAndRemap");
        
        UKismetAnimationLibrary_K2_MakePerlinNoiseVectorAndRemap_Params params {};
        params.X = X;
        params.Y = Y;
        params.Z = Z;
        params.RangeOutMinX = RangeOutMinX;
        params.RangeOutMaxX = RangeOutMaxX;
        params.RangeOutMinY = RangeOutMinY;
        params.RangeOutMaxY = RangeOutMaxY;
        params.RangeOutMinZ = RangeOutMinZ;
        params.RangeOutMaxZ = RangeOutMaxZ;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        return params.ReturnValue;
    }

    /**
     * Function:
     *         RVA    -> 0x0508CEB0
     *         Name   -> Function /Script/AnimGraphRuntime.KismetAnimationLibrary.K2_MakePerlinNoiseAndRemap
     *         Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
     * Parameters:
     *         float                                              Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         float                                              RangeOutMin                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         float                                              RangeOutMax                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     */
    float UKismetAnimationLibrary::STATIC_K2_MakePerlinNoiseAndRemap(float Value, float RangeOutMin, float RangeOutMax)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/AnimGraphRuntime.KismetAnimationLibrary.K2_MakePerlinNoiseAndRemap");
        
        UKismetAnimationLibrary_K2_MakePerlinNoiseAndRemap_Params params {};
        params.Value = Value;
        params.RangeOutMin = RangeOutMin;
        params.RangeOutMax = RangeOutMax;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        return params.ReturnValue;
    }

    /**
     * Function:
     *         RVA    -> 0x0508E200
     *         Name   -> Function /Script/AnimGraphRuntime.KismetAnimationLibrary.K2_LookAt
     *         Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
     * Parameters:
     *         CoreUObject::FTransform                            CurrentTransform                                           (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         CoreUObject::FVector                               TargetPosition                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         CoreUObject::FVector                               LookAtVector                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         bool                                               bUseUpVector                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         CoreUObject::FVector                               UpVector                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         float                                              ClampConeInDegree                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         CoreUObject::FTransform                            ReturnValue                                                (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     */
    CoreUObject::FTransform UKismetAnimationLibrary::STATIC_K2_LookAt(const CoreUObject::FTransform& CurrentTransform, const CoreUObject::FVector& TargetPosition, const CoreUObject::FVector& LookAtVector, bool bUseUpVector, const CoreUObject::FVector& UpVector, float ClampConeInDegree)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/AnimGraphRuntime.KismetAnimationLibrary.K2_LookAt");
        
        UKismetAnimationLibrary_K2_LookAt_Params params {};
        params.CurrentTransform = CurrentTransform;
        params.TargetPosition = TargetPosition;
        params.LookAtVector = LookAtVector;
        params.bUseUpVector = bUseUpVector;
        params.UpVector = UpVector;
        params.ClampConeInDegree = ClampConeInDegree;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        return params.ReturnValue;
    }

    /**
     * Function:
     *         RVA    -> 0x0508BF00
     *         Name   -> Function /Script/AnimGraphRuntime.KismetAnimationLibrary.K2_EndProfilingTimer
     *         Flags  -> (Final, Native, Static, Public, BlueprintCallable)
     * Parameters:
     *         bool                                               bLog                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         BasicTypes::FString                                LogPrefix                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     */
    float UKismetAnimationLibrary::STATIC_K2_EndProfilingTimer(bool bLog, const BasicTypes::FString& LogPrefix)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/AnimGraphRuntime.KismetAnimationLibrary.K2_EndProfilingTimer");
        
        UKismetAnimationLibrary_K2_EndProfilingTimer_Params params {};
        params.bLog = bLog;
        params.LogPrefix = LogPrefix;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        return params.ReturnValue;
    }

    /**
     * Function:
     *         RVA    -> 0x0508DA50
     *         Name   -> Function /Script/AnimGraphRuntime.KismetAnimationLibrary.K2_DistanceBetweenTwoSocketsAndMapRange
     *         Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
     * Parameters:
     *         Engine::USkeletalMeshComponent*                    Component                                                  (ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         BasicTypes::FName                                  SocketOrBoneNameA                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         Engine::ERelativeTransformSpace                    SocketSpaceA                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         BasicTypes::FName                                  SocketOrBoneNameB                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         Engine::ERelativeTransformSpace                    SocketSpaceB                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         bool                                               bRemapRange                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         float                                              InRangeMin                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         float                                              InRangeMax                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         float                                              OutRangeMin                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         float                                              OutRangeMax                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     */
    float UKismetAnimationLibrary::STATIC_K2_DistanceBetweenTwoSocketsAndMapRange(Engine::USkeletalMeshComponent* Component, const BasicTypes::FName& SocketOrBoneNameA, Engine::ERelativeTransformSpace SocketSpaceA, const BasicTypes::FName& SocketOrBoneNameB, Engine::ERelativeTransformSpace SocketSpaceB, bool bRemapRange, float InRangeMin, float InRangeMax, float OutRangeMin, float OutRangeMax)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/AnimGraphRuntime.KismetAnimationLibrary.K2_DistanceBetweenTwoSocketsAndMapRange");
        
        UKismetAnimationLibrary_K2_DistanceBetweenTwoSocketsAndMapRange_Params params {};
        params.Component = Component;
        params.SocketOrBoneNameA = SocketOrBoneNameA;
        params.SocketSpaceA = SocketSpaceA;
        params.SocketOrBoneNameB = SocketOrBoneNameB;
        params.SocketSpaceB = SocketSpaceB;
        params.bRemapRange = bRemapRange;
        params.InRangeMin = InRangeMin;
        params.InRangeMax = InRangeMax;
        params.OutRangeMin = OutRangeMin;
        params.OutRangeMax = OutRangeMax;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        return params.ReturnValue;
    }

    /**
     * Function:
     *         RVA    -> 0x0508D740
     *         Name   -> Function /Script/AnimGraphRuntime.KismetAnimationLibrary.K2_DirectionBetweenSockets
     *         Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
     * Parameters:
     *         Engine::USkeletalMeshComponent*                    Component                                                  (ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         BasicTypes::FName                                  SocketOrBoneNameFrom                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         BasicTypes::FName                                  SocketOrBoneNameTo                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         CoreUObject::FVector                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     */
    CoreUObject::FVector UKismetAnimationLibrary::STATIC_K2_DirectionBetweenSockets(Engine::USkeletalMeshComponent* Component, const BasicTypes::FName& SocketOrBoneNameFrom, const BasicTypes::FName& SocketOrBoneNameTo)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/AnimGraphRuntime.KismetAnimationLibrary.K2_DirectionBetweenSockets");
        
        UKismetAnimationLibrary_K2_DirectionBetweenSockets_Params params {};
        params.Component = Component;
        params.SocketOrBoneNameFrom = SocketOrBoneNameFrom;
        params.SocketOrBoneNameTo = SocketOrBoneNameTo;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        return params.ReturnValue;
    }

    /**
     * Function:
     *         RVA    -> 0x0508C0D0
     *         Name   -> Function /Script/AnimGraphRuntime.KismetAnimationLibrary.K2_CalculateVelocityFromSockets
     *         Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
     * Parameters:
     *         float                                              DeltaSeconds                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         Engine::USkeletalMeshComponent*                    Component                                                  (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         BasicTypes::FName                                  SocketOrBoneName                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         BasicTypes::FName                                  ReferenceSocketOrBone                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         Engine::ERelativeTransformSpace                    SocketSpace                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         CoreUObject::FVector                               OffsetInBoneSpace                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         AnimGraphRuntime::FPositionHistory                 History                                                    (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
     *         int32_t                                            NumberOfSamples                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         float                                              VelocityMin                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         float                                              VelocityMax                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         AnimGraphRuntime::EEasingFuncType                  EasingType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         Engine::FRuntimeFloatCurve                         CustomCurve                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
     *         float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     */
    float UKismetAnimationLibrary::STATIC_K2_CalculateVelocityFromSockets(float DeltaSeconds, Engine::USkeletalMeshComponent* Component, const BasicTypes::FName& SocketOrBoneName, const BasicTypes::FName& ReferenceSocketOrBone, Engine::ERelativeTransformSpace SocketSpace, const CoreUObject::FVector& OffsetInBoneSpace, AnimGraphRuntime::FPositionHistory* History, int32_t NumberOfSamples, float VelocityMin, float VelocityMax, AnimGraphRuntime::EEasingFuncType EasingType, const Engine::FRuntimeFloatCurve& CustomCurve)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/AnimGraphRuntime.KismetAnimationLibrary.K2_CalculateVelocityFromSockets");
        
        UKismetAnimationLibrary_K2_CalculateVelocityFromSockets_Params params {};
        params.DeltaSeconds = DeltaSeconds;
        params.Component = Component;
        params.SocketOrBoneName = SocketOrBoneName;
        params.ReferenceSocketOrBone = ReferenceSocketOrBone;
        params.SocketSpace = SocketSpace;
        params.OffsetInBoneSpace = OffsetInBoneSpace;
        params.NumberOfSamples = NumberOfSamples;
        params.VelocityMin = VelocityMin;
        params.VelocityMax = VelocityMax;
        params.EasingType = EasingType;
        params.CustomCurve = CustomCurve;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        if (History != nullptr)
            *History = params.History;
        
        return params.ReturnValue;
    }

    /**
     * Function:
     *         RVA    -> 0x0508CAA0
     *         Name   -> Function /Script/AnimGraphRuntime.KismetAnimationLibrary.K2_CalculateVelocityFromPositionHistory
     *         Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
     * Parameters:
     *         float                                              DeltaSeconds                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         CoreUObject::FVector                               Position                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         AnimGraphRuntime::FPositionHistory                 History                                                    (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
     *         int32_t                                            NumberOfSamples                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         float                                              VelocityMin                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         float                                              VelocityMax                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     */
    float UKismetAnimationLibrary::STATIC_K2_CalculateVelocityFromPositionHistory(float DeltaSeconds, const CoreUObject::FVector& Position, AnimGraphRuntime::FPositionHistory* History, int32_t NumberOfSamples, float VelocityMin, float VelocityMax)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/AnimGraphRuntime.KismetAnimationLibrary.K2_CalculateVelocityFromPositionHistory");
        
        UKismetAnimationLibrary_K2_CalculateVelocityFromPositionHistory_Params params {};
        params.DeltaSeconds = DeltaSeconds;
        params.Position = Position;
        params.NumberOfSamples = NumberOfSamples;
        params.VelocityMin = VelocityMin;
        params.VelocityMax = VelocityMax;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        if (History != nullptr)
            *History = params.History;
        
        return params.ReturnValue;
    }

    /**
     * Function:
     *         RVA    -> 0x0508BD70
     *         Name   -> Function /Script/AnimGraphRuntime.KismetAnimationLibrary.CalculateDirection
     *         Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
     * Parameters:
     *         CoreUObject::FVector                               Velocity                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         CoreUObject::FRotator                              BaseRotation                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
     *         float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     */
    float UKismetAnimationLibrary::STATIC_CalculateDirection(const CoreUObject::FVector& Velocity, const CoreUObject::FRotator& BaseRotation)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/AnimGraphRuntime.KismetAnimationLibrary.CalculateDirection");
        
        UKismetAnimationLibrary_CalculateDirection_Params params {};
        params.Velocity = Velocity;
        params.BaseRotation = BaseRotation;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        return params.ReturnValue;
    }

    /**
     * Function:
     *         RVA    -> 0x0508FCF0
     *         Name   -> Function /Script/AnimGraphRuntime.LayeredBoneBlendLibrary.SetBlendMask
     *         Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
     * Parameters:
     *         Engine::FAnimUpdateContext                         UpdateContext                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
     *         AnimGraphRuntime::FLayeredBoneBlendReference       LayeredBoneBlend                                           (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
     *         int32_t                                            PoseIndex                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         BasicTypes::FName                                  BlendMaskName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         AnimGraphRuntime::FLayeredBoneBlendReference       ReturnValue                                                (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
     */
    AnimGraphRuntime::FLayeredBoneBlendReference ULayeredBoneBlendLibrary::STATIC_SetBlendMask(const Engine::FAnimUpdateContext& UpdateContext, const AnimGraphRuntime::FLayeredBoneBlendReference& LayeredBoneBlend, int32_t PoseIndex, const BasicTypes::FName& BlendMaskName)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/AnimGraphRuntime.LayeredBoneBlendLibrary.SetBlendMask");
        
        ULayeredBoneBlendLibrary_SetBlendMask_Params params {};
        params.UpdateContext = UpdateContext;
        params.LayeredBoneBlend = LayeredBoneBlend;
        params.PoseIndex = PoseIndex;
        params.BlendMaskName = BlendMaskName;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        return params.ReturnValue;
    }

    /**
     * Function:
     *         RVA    -> 0x05090040
     *         Name   -> Function /Script/AnimGraphRuntime.LayeredBoneBlendLibrary.GetNumPoses
     *         Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
     * Parameters:
     *         AnimGraphRuntime::FLayeredBoneBlendReference       LayeredBoneBlend                                           (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
     *         int32_t                                            ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     */
    int32_t ULayeredBoneBlendLibrary::STATIC_GetNumPoses(const AnimGraphRuntime::FLayeredBoneBlendReference& LayeredBoneBlend)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/AnimGraphRuntime.LayeredBoneBlendLibrary.GetNumPoses");
        
        ULayeredBoneBlendLibrary_GetNumPoses_Params params {};
        params.LayeredBoneBlend = LayeredBoneBlend;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        return params.ReturnValue;
    }

    /**
     * Function:
     *         RVA    -> 0x05090400
     *         Name   -> Function /Script/AnimGraphRuntime.LayeredBoneBlendLibrary.ConvertToLayeredBoneBlend
     *         Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
     * Parameters:
     *         Engine::FAnimNodeReference                         Node                                                       (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
     *         Engine::EAnimNodeReferenceConversionResult         Result                                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         AnimGraphRuntime::FLayeredBoneBlendReference       ReturnValue                                                (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
     */
    AnimGraphRuntime::FLayeredBoneBlendReference ULayeredBoneBlendLibrary::STATIC_ConvertToLayeredBoneBlend(const Engine::FAnimNodeReference& Node, Engine::EAnimNodeReferenceConversionResult* Result)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/AnimGraphRuntime.LayeredBoneBlendLibrary.ConvertToLayeredBoneBlend");
        
        ULayeredBoneBlendLibrary_ConvertToLayeredBoneBlend_Params params {};
        params.Node = Node;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        if (Result != nullptr)
            *Result = params.Result;
        
        return params.ReturnValue;
    }

    /**
     * Function:
     *         RVA    -> 0x05090180
     *         Name   -> Function /Script/AnimGraphRuntime.LayeredBoneBlendLibrary.ConvertToLayeredBlendPerBonePure
     *         Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
     * Parameters:
     *         Engine::FAnimNodeReference                         Node                                                       (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
     *         AnimGraphRuntime::FLayeredBoneBlendReference       LayeredBoneBlend                                           (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
     *         bool                                               Result                                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         void                                               ReturnValue
     */
    void ULayeredBoneBlendLibrary::STATIC_ConvertToLayeredBlendPerBonePure(const Engine::FAnimNodeReference& Node, AnimGraphRuntime::FLayeredBoneBlendReference* LayeredBoneBlend, bool* Result)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/AnimGraphRuntime.LayeredBoneBlendLibrary.ConvertToLayeredBlendPerBonePure");
        
        ULayeredBoneBlendLibrary_ConvertToLayeredBlendPerBonePure_Params params {};
        params.Node = Node;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        if (LayeredBoneBlend != nullptr)
            *LayeredBoneBlend = params.LayeredBoneBlend;
        if (Result != nullptr)
            *Result = params.Result;
    }

    /**
     * Function:
     *         RVA    -> 0x05090AE0
     *         Name   -> Function /Script/AnimGraphRuntime.LinkedAnimGraphLibrary.HasLinkedAnimInstance
     *         Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
     * Parameters:
     *         AnimGraphRuntime::FLinkedAnimGraphReference        Node                                                       (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
     *         bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     */
    bool ULinkedAnimGraphLibrary::STATIC_HasLinkedAnimInstance(const AnimGraphRuntime::FLinkedAnimGraphReference& Node)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/AnimGraphRuntime.LinkedAnimGraphLibrary.HasLinkedAnimInstance");
        
        ULinkedAnimGraphLibrary_HasLinkedAnimInstance_Params params {};
        params.Node = Node;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        return params.ReturnValue;
    }

    /**
     * Function:
     *         RVA    -> 0x05090980
     *         Name   -> Function /Script/AnimGraphRuntime.LinkedAnimGraphLibrary.GetLinkedAnimInstance
     *         Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
     * Parameters:
     *         AnimGraphRuntime::FLinkedAnimGraphReference        Node                                                       (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
     *         Engine::UAnimInstance*                             ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     */
    Engine::UAnimInstance* ULinkedAnimGraphLibrary::STATIC_GetLinkedAnimInstance(const AnimGraphRuntime::FLinkedAnimGraphReference& Node)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/AnimGraphRuntime.LinkedAnimGraphLibrary.GetLinkedAnimInstance");
        
        ULinkedAnimGraphLibrary_GetLinkedAnimInstance_Params params {};
        params.Node = Node;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        return params.ReturnValue;
    }

    /**
     * Function:
     *         RVA    -> 0x05090C30
     *         Name   -> Function /Script/AnimGraphRuntime.LinkedAnimGraphLibrary.ConvertToLinkedAnimGraphPure
     *         Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
     * Parameters:
     *         Engine::FAnimNodeReference                         Node                                                       (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
     *         AnimGraphRuntime::FLinkedAnimGraphReference        LinkedAnimGraph                                            (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
     *         bool                                               Result                                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         void                                               ReturnValue
     */
    void ULinkedAnimGraphLibrary::STATIC_ConvertToLinkedAnimGraphPure(const Engine::FAnimNodeReference& Node, AnimGraphRuntime::FLinkedAnimGraphReference* LinkedAnimGraph, bool* Result)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/AnimGraphRuntime.LinkedAnimGraphLibrary.ConvertToLinkedAnimGraphPure");
        
        ULinkedAnimGraphLibrary_ConvertToLinkedAnimGraphPure_Params params {};
        params.Node = Node;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        if (LinkedAnimGraph != nullptr)
            *LinkedAnimGraph = params.LinkedAnimGraph;
        if (Result != nullptr)
            *Result = params.Result;
    }

    /**
     * Function:
     *         RVA    -> 0x05090EB0
     *         Name   -> Function /Script/AnimGraphRuntime.LinkedAnimGraphLibrary.ConvertToLinkedAnimGraph
     *         Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
     * Parameters:
     *         Engine::FAnimNodeReference                         Node                                                       (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
     *         Engine::EAnimNodeReferenceConversionResult         Result                                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         AnimGraphRuntime::FLinkedAnimGraphReference        ReturnValue                                                (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
     */
    AnimGraphRuntime::FLinkedAnimGraphReference ULinkedAnimGraphLibrary::STATIC_ConvertToLinkedAnimGraph(const Engine::FAnimNodeReference& Node, Engine::EAnimNodeReferenceConversionResult* Result)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/AnimGraphRuntime.LinkedAnimGraphLibrary.ConvertToLinkedAnimGraph");
        
        ULinkedAnimGraphLibrary_ConvertToLinkedAnimGraph_Params params {};
        params.Node = Node;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        if (Result != nullptr)
            *Result = params.Result;
        
        return params.ReturnValue;
    }

    /**
     * Function:
     *         RVA    -> 0x05091290
     *         Name   -> Function /Script/AnimGraphRuntime.PlayMontageCallbackProxy.OnNotifyEndReceived
     *         Flags  -> (Final, Native, Protected, HasOutParms)
     * Parameters:
     *         BasicTypes::FName                                  NotifyName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         Engine::FBranchingPointNotifyPayload               BranchingPointNotifyPayload                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
     *         void                                               ReturnValue
     */
    void UPlayMontageCallbackProxy::OnNotifyEndReceived(const BasicTypes::FName& NotifyName, const Engine::FBranchingPointNotifyPayload& BranchingPointNotifyPayload)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/AnimGraphRuntime.PlayMontageCallbackProxy.OnNotifyEndReceived");
        
        UPlayMontageCallbackProxy_OnNotifyEndReceived_Params params {};
        params.NotifyName = NotifyName;
        params.BranchingPointNotifyPayload = BranchingPointNotifyPayload;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
    }

    /**
     * Function:
     *         RVA    -> 0x05091460
     *         Name   -> Function /Script/AnimGraphRuntime.PlayMontageCallbackProxy.OnNotifyBeginReceived
     *         Flags  -> (Final, Native, Protected, HasOutParms)
     * Parameters:
     *         BasicTypes::FName                                  NotifyName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         Engine::FBranchingPointNotifyPayload               BranchingPointNotifyPayload                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
     *         void                                               ReturnValue
     */
    void UPlayMontageCallbackProxy::OnNotifyBeginReceived(const BasicTypes::FName& NotifyName, const Engine::FBranchingPointNotifyPayload& BranchingPointNotifyPayload)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/AnimGraphRuntime.PlayMontageCallbackProxy.OnNotifyBeginReceived");
        
        UPlayMontageCallbackProxy_OnNotifyBeginReceived_Params params {};
        params.NotifyName = NotifyName;
        params.BranchingPointNotifyPayload = BranchingPointNotifyPayload;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
    }

    /**
     * Function:
     *         RVA    -> 0x05091630
     *         Name   -> Function /Script/AnimGraphRuntime.PlayMontageCallbackProxy.OnMontageEnded
     *         Flags  -> (Final, Native, Protected)
     * Parameters:
     *         Engine::UAnimMontage*                              Montage                                                    (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         bool                                               bInterrupted                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         void                                               ReturnValue
     */
    void UPlayMontageCallbackProxy::OnMontageEnded(Engine::UAnimMontage* Montage, bool bInterrupted)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/AnimGraphRuntime.PlayMontageCallbackProxy.OnMontageEnded");
        
        UPlayMontageCallbackProxy_OnMontageEnded_Params params {};
        params.Montage = Montage;
        params.bInterrupted = bInterrupted;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
    }

    /**
     * Function:
     *         RVA    -> 0x050917E0
     *         Name   -> Function /Script/AnimGraphRuntime.PlayMontageCallbackProxy.OnMontageBlendingOut
     *         Flags  -> (Final, Native, Protected)
     * Parameters:
     *         Engine::UAnimMontage*                              Montage                                                    (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         bool                                               bInterrupted                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         void                                               ReturnValue
     */
    void UPlayMontageCallbackProxy::OnMontageBlendingOut(Engine::UAnimMontage* Montage, bool bInterrupted)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/AnimGraphRuntime.PlayMontageCallbackProxy.OnMontageBlendingOut");
        
        UPlayMontageCallbackProxy_OnMontageBlendingOut_Params params {};
        params.Montage = Montage;
        params.bInterrupted = bInterrupted;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
    }

    /**
     * Function:
     *         RVA    -> 0x05091990
     *         Name   -> Function /Script/AnimGraphRuntime.PlayMontageCallbackProxy.CreateProxyObjectForPlayMontage
     *         Flags  -> (Final, Native, Static, Public, BlueprintCallable)
     * Parameters:
     *         Engine::USkeletalMeshComponent*                    InSkeletalMeshComponent                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         Engine::UAnimMontage*                              MontageToPlay                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         float                                              PlayRate                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         float                                              StartingPosition                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         BasicTypes::FName                                  StartingSection                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         AnimGraphRuntime::UPlayMontageCallbackProxy*       ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     */
    AnimGraphRuntime::UPlayMontageCallbackProxy* UPlayMontageCallbackProxy::STATIC_CreateProxyObjectForPlayMontage(Engine::USkeletalMeshComponent* InSkeletalMeshComponent, Engine::UAnimMontage* MontageToPlay, float PlayRate, float StartingPosition, const BasicTypes::FName& StartingSection)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/AnimGraphRuntime.PlayMontageCallbackProxy.CreateProxyObjectForPlayMontage");
        
        UPlayMontageCallbackProxy_CreateProxyObjectForPlayMontage_Params params {};
        params.InSkeletalMeshComponent = InSkeletalMeshComponent;
        params.MontageToPlay = MontageToPlay;
        params.PlayRate = PlayRate;
        params.StartingPosition = StartingPosition;
        params.StartingSection = StartingSection;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        return params.ReturnValue;
    }

    /**
     * Function:
     *         RVA    -> 0x050954C0
     *         Name   -> Function /Script/AnimGraphRuntime.SequenceEvaluatorLibrary.SetSequenceWithInertialBlending
     *         Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
     * Parameters:
     *         Engine::FAnimUpdateContext                         UpdateContext                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
     *         AnimGraphRuntime::FSequenceEvaluatorReference      SequenceEvaluator                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
     *         Engine::UAnimSequenceBase*                         Sequence                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         float                                              BlendTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         AnimGraphRuntime::FSequenceEvaluatorReference      ReturnValue                                                (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
     */
    AnimGraphRuntime::FSequenceEvaluatorReference USequenceEvaluatorLibrary::STATIC_SetSequenceWithInertialBlending(const Engine::FAnimUpdateContext& UpdateContext, const AnimGraphRuntime::FSequenceEvaluatorReference& SequenceEvaluator, Engine::UAnimSequenceBase* Sequence, float BlendTime)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/AnimGraphRuntime.SequenceEvaluatorLibrary.SetSequenceWithInertialBlending");
        
        USequenceEvaluatorLibrary_SetSequenceWithInertialBlending_Params params {};
        params.UpdateContext = UpdateContext;
        params.SequenceEvaluator = SequenceEvaluator;
        params.Sequence = Sequence;
        params.BlendTime = BlendTime;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        return params.ReturnValue;
    }

    /**
     * Function:
     *         RVA    -> 0x05095820
     *         Name   -> Function /Script/AnimGraphRuntime.SequenceEvaluatorLibrary.SetSequence
     *         Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
     * Parameters:
     *         AnimGraphRuntime::FSequenceEvaluatorReference      SequenceEvaluator                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
     *         Engine::UAnimSequenceBase*                         Sequence                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         AnimGraphRuntime::FSequenceEvaluatorReference      ReturnValue                                                (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
     */
    AnimGraphRuntime::FSequenceEvaluatorReference USequenceEvaluatorLibrary::STATIC_SetSequence(const AnimGraphRuntime::FSequenceEvaluatorReference& SequenceEvaluator, Engine::UAnimSequenceBase* Sequence)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/AnimGraphRuntime.SequenceEvaluatorLibrary.SetSequence");
        
        USequenceEvaluatorLibrary_SetSequence_Params params {};
        params.SequenceEvaluator = SequenceEvaluator;
        params.Sequence = Sequence;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        return params.ReturnValue;
    }

    /**
     * Function:
     *         RVA    -> 0x05095CB0
     *         Name   -> Function /Script/AnimGraphRuntime.SequenceEvaluatorLibrary.SetExplicitTime
     *         Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
     * Parameters:
     *         AnimGraphRuntime::FSequenceEvaluatorReference      SequenceEvaluator                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
     *         float                                              Time                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         AnimGraphRuntime::FSequenceEvaluatorReference      ReturnValue                                                (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
     */
    AnimGraphRuntime::FSequenceEvaluatorReference USequenceEvaluatorLibrary::STATIC_SetExplicitTime(const AnimGraphRuntime::FSequenceEvaluatorReference& SequenceEvaluator, float Time)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/AnimGraphRuntime.SequenceEvaluatorLibrary.SetExplicitTime");
        
        USequenceEvaluatorLibrary_SetExplicitTime_Params params {};
        params.SequenceEvaluator = SequenceEvaluator;
        params.Time = Time;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        return params.ReturnValue;
    }

    /**
     * Function:
     *         RVA    -> 0x05095200
     *         Name   -> Function /Script/AnimGraphRuntime.SequenceEvaluatorLibrary.GetSequence
     *         Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
     * Parameters:
     *         AnimGraphRuntime::FSequenceEvaluatorReference      SequenceEvaluator                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
     *         Engine::UAnimSequenceBase*                         ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     */
    Engine::UAnimSequenceBase* USequenceEvaluatorLibrary::STATIC_GetSequence(const AnimGraphRuntime::FSequenceEvaluatorReference& SequenceEvaluator)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/AnimGraphRuntime.SequenceEvaluatorLibrary.GetSequence");
        
        USequenceEvaluatorLibrary_GetSequence_Params params {};
        params.SequenceEvaluator = SequenceEvaluator;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        return params.ReturnValue;
    }

    /**
     * Function:
     *         RVA    -> 0x05095360
     *         Name   -> Function /Script/AnimGraphRuntime.SequenceEvaluatorLibrary.GetAccumulatedTime
     *         Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
     * Parameters:
     *         AnimGraphRuntime::FSequenceEvaluatorReference      SequenceEvaluator                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
     *         float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     */
    float USequenceEvaluatorLibrary::STATIC_GetAccumulatedTime(const AnimGraphRuntime::FSequenceEvaluatorReference& SequenceEvaluator)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/AnimGraphRuntime.SequenceEvaluatorLibrary.GetAccumulatedTime");
        
        USequenceEvaluatorLibrary_GetAccumulatedTime_Params params {};
        params.SequenceEvaluator = SequenceEvaluator;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        return params.ReturnValue;
    }

    /**
     * Function:
     *         RVA    -> 0x05095EA0
     *         Name   -> Function /Script/AnimGraphRuntime.SequenceEvaluatorLibrary.ConvertToSequenceEvaluatorPure
     *         Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
     * Parameters:
     *         Engine::FAnimNodeReference                         Node                                                       (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
     *         AnimGraphRuntime::FSequenceEvaluatorReference      SequenceEvaluator                                          (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
     *         bool                                               Result                                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         void                                               ReturnValue
     */
    void USequenceEvaluatorLibrary::STATIC_ConvertToSequenceEvaluatorPure(const Engine::FAnimNodeReference& Node, AnimGraphRuntime::FSequenceEvaluatorReference* SequenceEvaluator, bool* Result)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/AnimGraphRuntime.SequenceEvaluatorLibrary.ConvertToSequenceEvaluatorPure");
        
        USequenceEvaluatorLibrary_ConvertToSequenceEvaluatorPure_Params params {};
        params.Node = Node;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        if (SequenceEvaluator != nullptr)
            *SequenceEvaluator = params.SequenceEvaluator;
        if (Result != nullptr)
            *Result = params.Result;
    }

    /**
     * Function:
     *         RVA    -> 0x05096120
     *         Name   -> Function /Script/AnimGraphRuntime.SequenceEvaluatorLibrary.ConvertToSequenceEvaluator
     *         Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
     * Parameters:
     *         Engine::FAnimNodeReference                         Node                                                       (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
     *         Engine::EAnimNodeReferenceConversionResult         Result                                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         AnimGraphRuntime::FSequenceEvaluatorReference      ReturnValue                                                (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
     */
    AnimGraphRuntime::FSequenceEvaluatorReference USequenceEvaluatorLibrary::STATIC_ConvertToSequenceEvaluator(const Engine::FAnimNodeReference& Node, Engine::EAnimNodeReferenceConversionResult* Result)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/AnimGraphRuntime.SequenceEvaluatorLibrary.ConvertToSequenceEvaluator");
        
        USequenceEvaluatorLibrary_ConvertToSequenceEvaluator_Params params {};
        params.Node = Node;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        if (Result != nullptr)
            *Result = params.Result;
        
        return params.ReturnValue;
    }

    /**
     * Function:
     *         RVA    -> 0x05095A00
     *         Name   -> Function /Script/AnimGraphRuntime.SequenceEvaluatorLibrary.AdvanceTime
     *         Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
     * Parameters:
     *         Engine::FAnimUpdateContext                         UpdateContext                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
     *         AnimGraphRuntime::FSequenceEvaluatorReference      SequenceEvaluator                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
     *         float                                              PlayRate                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         AnimGraphRuntime::FSequenceEvaluatorReference      ReturnValue                                                (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
     */
    AnimGraphRuntime::FSequenceEvaluatorReference USequenceEvaluatorLibrary::STATIC_AdvanceTime(const Engine::FAnimUpdateContext& UpdateContext, const AnimGraphRuntime::FSequenceEvaluatorReference& SequenceEvaluator, float PlayRate)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/AnimGraphRuntime.SequenceEvaluatorLibrary.AdvanceTime");
        
        USequenceEvaluatorLibrary_AdvanceTime_Params params {};
        params.UpdateContext = UpdateContext;
        params.SequenceEvaluator = SequenceEvaluator;
        params.PlayRate = PlayRate;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        return params.ReturnValue;
    }

    /**
     * Function:
     *         RVA    -> 0x05097A60
     *         Name   -> Function /Script/AnimGraphRuntime.SequencePlayerLibrary.SetStartPosition
     *         Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
     * Parameters:
     *         AnimGraphRuntime::FSequencePlayerReference         SequencePlayer                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
     *         float                                              StartPosition                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         AnimGraphRuntime::FSequencePlayerReference         ReturnValue                                                (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
     */
    AnimGraphRuntime::FSequencePlayerReference USequencePlayerLibrary::STATIC_SetStartPosition(const AnimGraphRuntime::FSequencePlayerReference& SequencePlayer, float StartPosition)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/AnimGraphRuntime.SequencePlayerLibrary.SetStartPosition");
        
        USequencePlayerLibrary_SetStartPosition_Params params {};
        params.SequencePlayer = SequencePlayer;
        params.StartPosition = StartPosition;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        return params.ReturnValue;
    }

    /**
     * Function:
     *         RVA    -> 0x05097330
     *         Name   -> Function /Script/AnimGraphRuntime.SequencePlayerLibrary.SetSequenceWithInertialBlending
     *         Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
     * Parameters:
     *         Engine::FAnimUpdateContext                         UpdateContext                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
     *         AnimGraphRuntime::FSequencePlayerReference         SequencePlayer                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
     *         Engine::UAnimSequenceBase*                         Sequence                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         float                                              BlendTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         AnimGraphRuntime::FSequencePlayerReference         ReturnValue                                                (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
     */
    AnimGraphRuntime::FSequencePlayerReference USequencePlayerLibrary::STATIC_SetSequenceWithInertialBlending(const Engine::FAnimUpdateContext& UpdateContext, const AnimGraphRuntime::FSequencePlayerReference& SequencePlayer, Engine::UAnimSequenceBase* Sequence, float BlendTime)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/AnimGraphRuntime.SequencePlayerLibrary.SetSequenceWithInertialBlending");
        
        USequencePlayerLibrary_SetSequenceWithInertialBlending_Params params {};
        params.UpdateContext = UpdateContext;
        params.SequencePlayer = SequencePlayer;
        params.Sequence = Sequence;
        params.BlendTime = BlendTime;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        return params.ReturnValue;
    }

    /**
     * Function:
     *         RVA    -> 0x05097690
     *         Name   -> Function /Script/AnimGraphRuntime.SequencePlayerLibrary.SetSequence
     *         Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
     * Parameters:
     *         AnimGraphRuntime::FSequencePlayerReference         SequencePlayer                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
     *         Engine::UAnimSequenceBase*                         Sequence                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         AnimGraphRuntime::FSequencePlayerReference         ReturnValue                                                (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
     */
    AnimGraphRuntime::FSequencePlayerReference USequencePlayerLibrary::STATIC_SetSequence(const AnimGraphRuntime::FSequencePlayerReference& SequencePlayer, Engine::UAnimSequenceBase* Sequence)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/AnimGraphRuntime.SequencePlayerLibrary.SetSequence");
        
        USequencePlayerLibrary_SetSequence_Params params {};
        params.SequencePlayer = SequencePlayer;
        params.Sequence = Sequence;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        return params.ReturnValue;
    }

    /**
     * Function:
     *         RVA    -> 0x05097870
     *         Name   -> Function /Script/AnimGraphRuntime.SequencePlayerLibrary.SetPlayRate
     *         Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
     * Parameters:
     *         AnimGraphRuntime::FSequencePlayerReference         SequencePlayer                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
     *         float                                              PlayRate                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         AnimGraphRuntime::FSequencePlayerReference         ReturnValue                                                (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
     */
    AnimGraphRuntime::FSequencePlayerReference USequencePlayerLibrary::STATIC_SetPlayRate(const AnimGraphRuntime::FSequencePlayerReference& SequencePlayer, float PlayRate)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/AnimGraphRuntime.SequencePlayerLibrary.SetPlayRate");
        
        USequencePlayerLibrary_SetPlayRate_Params params {};
        params.SequencePlayer = SequencePlayer;
        params.PlayRate = PlayRate;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        return params.ReturnValue;
    }

    /**
     * Function:
     *         RVA    -> 0x05097C50
     *         Name   -> Function /Script/AnimGraphRuntime.SequencePlayerLibrary.SetAccumulatedTime
     *         Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
     * Parameters:
     *         AnimGraphRuntime::FSequencePlayerReference         SequencePlayer                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
     *         float                                              Time                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         AnimGraphRuntime::FSequencePlayerReference         ReturnValue                                                (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
     */
    AnimGraphRuntime::FSequencePlayerReference USequencePlayerLibrary::STATIC_SetAccumulatedTime(const AnimGraphRuntime::FSequencePlayerReference& SequencePlayer, float Time)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/AnimGraphRuntime.SequencePlayerLibrary.SetAccumulatedTime");
        
        USequencePlayerLibrary_SetAccumulatedTime_Params params {};
        params.SequencePlayer = SequencePlayer;
        params.Time = Time;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        return params.ReturnValue;
    }

    /**
     * Function:
     *         RVA    -> 0x05096D20
     *         Name   -> Function /Script/AnimGraphRuntime.SequencePlayerLibrary.GetStartPosition
     *         Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
     * Parameters:
     *         AnimGraphRuntime::FSequencePlayerReference         SequencePlayer                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
     *         float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     */
    float USequencePlayerLibrary::STATIC_GetStartPosition(const AnimGraphRuntime::FSequencePlayerReference& SequencePlayer)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/AnimGraphRuntime.SequencePlayerLibrary.GetStartPosition");
        
        USequencePlayerLibrary_GetStartPosition_Params params {};
        params.SequencePlayer = SequencePlayer;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        return params.ReturnValue;
    }

    /**
     * Function:
     *         RVA    -> 0x05096FE0
     *         Name   -> Function /Script/AnimGraphRuntime.SequencePlayerLibrary.GetSequencePure
     *         Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
     * Parameters:
     *         AnimGraphRuntime::FSequencePlayerReference         SequencePlayer                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
     *         Engine::UAnimSequenceBase*                         ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     */
    Engine::UAnimSequenceBase* USequencePlayerLibrary::STATIC_GetSequencePure(const AnimGraphRuntime::FSequencePlayerReference& SequencePlayer)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/AnimGraphRuntime.SequencePlayerLibrary.GetSequencePure");
        
        USequencePlayerLibrary_GetSequencePure_Params params {};
        params.SequencePlayer = SequencePlayer;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        return params.ReturnValue;
    }

    /**
     * Function:
     *         RVA    -> 0x05097140
     *         Name   -> Function /Script/AnimGraphRuntime.SequencePlayerLibrary.GetSequence
     *         Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
     * Parameters:
     *         AnimGraphRuntime::FSequencePlayerReference         SequencePlayer                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
     *         Engine::UAnimSequenceBase*                         SequenceBase                                               (Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         AnimGraphRuntime::FSequencePlayerReference         ReturnValue                                                (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
     */
    AnimGraphRuntime::FSequencePlayerReference USequencePlayerLibrary::STATIC_GetSequence(const AnimGraphRuntime::FSequencePlayerReference& SequencePlayer, Engine::UAnimSequenceBase** SequenceBase)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/AnimGraphRuntime.SequencePlayerLibrary.GetSequence");
        
        USequencePlayerLibrary_GetSequence_Params params {};
        params.SequencePlayer = SequencePlayer;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        if (SequenceBase != nullptr)
            *SequenceBase = params.SequenceBase;
        
        return params.ReturnValue;
    }

    /**
     * Function:
     *         RVA    -> 0x05096BC0
     *         Name   -> Function /Script/AnimGraphRuntime.SequencePlayerLibrary.GetPlayRate
     *         Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
     * Parameters:
     *         AnimGraphRuntime::FSequencePlayerReference         SequencePlayer                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
     *         float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     */
    float USequencePlayerLibrary::STATIC_GetPlayRate(const AnimGraphRuntime::FSequencePlayerReference& SequencePlayer)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/AnimGraphRuntime.SequencePlayerLibrary.GetPlayRate");
        
        USequencePlayerLibrary_GetPlayRate_Params params {};
        params.SequencePlayer = SequencePlayer;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        return params.ReturnValue;
    }

    /**
     * Function:
     *         RVA    -> 0x05096A70
     *         Name   -> Function /Script/AnimGraphRuntime.SequencePlayerLibrary.GetLoopAnimation
     *         Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
     * Parameters:
     *         AnimGraphRuntime::FSequencePlayerReference         SequencePlayer                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
     *         bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     */
    bool USequencePlayerLibrary::STATIC_GetLoopAnimation(const AnimGraphRuntime::FSequencePlayerReference& SequencePlayer)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/AnimGraphRuntime.SequencePlayerLibrary.GetLoopAnimation");
        
        USequencePlayerLibrary_GetLoopAnimation_Params params {};
        params.SequencePlayer = SequencePlayer;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        return params.ReturnValue;
    }

    /**
     * Function:
     *         RVA    -> 0x05096E80
     *         Name   -> Function /Script/AnimGraphRuntime.SequencePlayerLibrary.GetAccumulatedTime
     *         Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
     * Parameters:
     *         AnimGraphRuntime::FSequencePlayerReference         SequencePlayer                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
     *         float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     */
    float USequencePlayerLibrary::STATIC_GetAccumulatedTime(const AnimGraphRuntime::FSequencePlayerReference& SequencePlayer)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/AnimGraphRuntime.SequencePlayerLibrary.GetAccumulatedTime");
        
        USequencePlayerLibrary_GetAccumulatedTime_Params params {};
        params.SequencePlayer = SequencePlayer;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        return params.ReturnValue;
    }

    /**
     * Function:
     *         RVA    -> 0x05097E40
     *         Name   -> Function /Script/AnimGraphRuntime.SequencePlayerLibrary.ConvertToSequencePlayerPure
     *         Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
     * Parameters:
     *         Engine::FAnimNodeReference                         Node                                                       (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
     *         AnimGraphRuntime::FSequencePlayerReference         SequencePlayer                                             (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
     *         bool                                               Result                                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         void                                               ReturnValue
     */
    void USequencePlayerLibrary::STATIC_ConvertToSequencePlayerPure(const Engine::FAnimNodeReference& Node, AnimGraphRuntime::FSequencePlayerReference* SequencePlayer, bool* Result)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/AnimGraphRuntime.SequencePlayerLibrary.ConvertToSequencePlayerPure");
        
        USequencePlayerLibrary_ConvertToSequencePlayerPure_Params params {};
        params.Node = Node;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        if (SequencePlayer != nullptr)
            *SequencePlayer = params.SequencePlayer;
        if (Result != nullptr)
            *Result = params.Result;
    }

    /**
     * Function:
     *         RVA    -> 0x050980C0
     *         Name   -> Function /Script/AnimGraphRuntime.SequencePlayerLibrary.ConvertToSequencePlayer
     *         Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
     * Parameters:
     *         Engine::FAnimNodeReference                         Node                                                       (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
     *         Engine::EAnimNodeReferenceConversionResult         Result                                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         AnimGraphRuntime::FSequencePlayerReference         ReturnValue                                                (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
     */
    AnimGraphRuntime::FSequencePlayerReference USequencePlayerLibrary::STATIC_ConvertToSequencePlayer(const Engine::FAnimNodeReference& Node, Engine::EAnimNodeReferenceConversionResult* Result)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/AnimGraphRuntime.SequencePlayerLibrary.ConvertToSequencePlayer");
        
        USequencePlayerLibrary_ConvertToSequencePlayer_Params params {};
        params.Node = Node;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        if (Result != nullptr)
            *Result = params.Result;
        
        return params.ReturnValue;
    }

    /**
     * Function:
     *         RVA    -> 0x05096840
     *         Name   -> Function /Script/AnimGraphRuntime.SequencePlayerLibrary.ComputePlayRateFromDuration
     *         Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
     * Parameters:
     *         AnimGraphRuntime::FSequencePlayerReference         SequencePlayer                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
     *         float                                              Duration                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     */
    float USequencePlayerLibrary::STATIC_ComputePlayRateFromDuration(const AnimGraphRuntime::FSequencePlayerReference& SequencePlayer, float Duration)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/AnimGraphRuntime.SequencePlayerLibrary.ComputePlayRateFromDuration");
        
        USequencePlayerLibrary_ComputePlayRateFromDuration_Params params {};
        params.SequencePlayer = SequencePlayer;
        params.Duration = Duration;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        return params.ReturnValue;
    }

    /**
     * Function:
     *         RVA    -> 0x05098AD0
     *         Name   -> Function /Script/AnimGraphRuntime.SkeletalControlLibrary.SetAlpha
     *         Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
     * Parameters:
     *         AnimGraphRuntime::FSkeletalControlReference        SkeletalControl                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
     *         float                                              Alpha                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         AnimGraphRuntime::FSkeletalControlReference        ReturnValue                                                (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
     */
    AnimGraphRuntime::FSkeletalControlReference USkeletalControlLibrary::STATIC_SetAlpha(const AnimGraphRuntime::FSkeletalControlReference& SkeletalControl, float Alpha)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/AnimGraphRuntime.SkeletalControlLibrary.SetAlpha");
        
        USkeletalControlLibrary_SetAlpha_Params params {};
        params.SkeletalControl = SkeletalControl;
        params.Alpha = Alpha;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        return params.ReturnValue;
    }

    /**
     * Function:
     *         RVA    -> 0x05098990
     *         Name   -> Function /Script/AnimGraphRuntime.SkeletalControlLibrary.GetAlpha
     *         Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
     * Parameters:
     *         AnimGraphRuntime::FSkeletalControlReference        SkeletalControl                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
     *         float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     */
    float USkeletalControlLibrary::STATIC_GetAlpha(const AnimGraphRuntime::FSkeletalControlReference& SkeletalControl)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/AnimGraphRuntime.SkeletalControlLibrary.GetAlpha");
        
        USkeletalControlLibrary_GetAlpha_Params params {};
        params.SkeletalControl = SkeletalControl;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        return params.ReturnValue;
    }

    /**
     * Function:
     *         RVA    -> 0x05098CC0
     *         Name   -> Function /Script/AnimGraphRuntime.SkeletalControlLibrary.ConvertToSkeletalControlPure
     *         Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
     * Parameters:
     *         Engine::FAnimNodeReference                         Node                                                       (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
     *         AnimGraphRuntime::FSkeletalControlReference        SkeletalControl                                            (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
     *         bool                                               Result                                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         void                                               ReturnValue
     */
    void USkeletalControlLibrary::STATIC_ConvertToSkeletalControlPure(const Engine::FAnimNodeReference& Node, AnimGraphRuntime::FSkeletalControlReference* SkeletalControl, bool* Result)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/AnimGraphRuntime.SkeletalControlLibrary.ConvertToSkeletalControlPure");
        
        USkeletalControlLibrary_ConvertToSkeletalControlPure_Params params {};
        params.Node = Node;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        if (SkeletalControl != nullptr)
            *SkeletalControl = params.SkeletalControl;
        if (Result != nullptr)
            *Result = params.Result;
    }

    /**
     * Function:
     *         RVA    -> 0x05098F40
     *         Name   -> Function /Script/AnimGraphRuntime.SkeletalControlLibrary.ConvertToSkeletalControl
     *         Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
     * Parameters:
     *         Engine::FAnimNodeReference                         Node                                                       (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
     *         Engine::EAnimNodeReferenceConversionResult         Result                                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
     *         AnimGraphRuntime::FSkeletalControlReference        ReturnValue                                                (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
     */
    AnimGraphRuntime::FSkeletalControlReference USkeletalControlLibrary::STATIC_ConvertToSkeletalControl(const Engine::FAnimNodeReference& Node, Engine::EAnimNodeReferenceConversionResult* Result)
    {
        static CoreUObject::UFunction* fn = nullptr;
        if (!fn)
            fn = CoreUObject::UObject::FindObject<CoreUObject::UFunction>("Function /Script/AnimGraphRuntime.SkeletalControlLibrary.ConvertToSkeletalControl");
        
        USkeletalControlLibrary_ConvertToSkeletalControl_Params params {};
        params.Node = Node;
        
        auto flags = fn->FunctionFlags;
        CoreUObject::UObject::ProcessEvent(fn, &params);
        fn->FunctionFlags = flags;
        
        if (Result != nullptr)
            *Result = params.Result;
        
        return params.ReturnValue;
    }

}

#ifdef _MSC_VER
    #pragma pack(pop)
#endif
